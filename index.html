<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <title>Budget Command Center</title>

  <style>
    body { margin:0; font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif; background:#0b1220; color:#e8eefc; padding:16px; }
    h1 { font-size:18px; margin:0 0 12px; }
    .card { background:#121a2b; padding:16px; border-radius:12px; margin-bottom:16px; border:1px solid #24314f; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
    button { padding:10px 14px; border-radius:10px; border:none; font-weight:900; cursor:pointer; }
    .primary { background:#64d2ff; color:#0b1220; }
    .danger { background:#ff6b6b; color:#fff; }
    .ghost { background:#0f1726; color:#e8eefc; border:1px solid #24314f; }
    input, select { padding:10px; border-radius:10px; border:1px solid #24314f; background:#0f1726; color:#e8eefc; width:100%; }
    label { font-size:12px; color:#9fb0d0; display:block; margin-bottom:6px; }
    table { width:100%; font-size:12px; border-collapse:collapse; }
    th, td { padding:8px 6px; border-bottom:1px solid #24314f; vertical-align:top; }
    th { color:#9fb0d0; text-align:left; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #24314f; border-radius:999px; color:#9fb0d0; font-size:11px; }
    .pos { color:#6bff95; }
    .neg { color:#ff6b6b; }
    .small { font-size:12px; color:#9fb0d0; line-height:1.4; margin:8px 0 0; }
    .kpi { font-size:34px; font-weight:950; margin:6px 0 0; letter-spacing:-.5px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap:10px; }
    @media(min-width:820px){ .grid2 { grid-template-columns: 1fr 1fr; } }
    .kpiBox { background:#0f1726; border:1px solid #24314f; border-radius:12px; padding:12px; }
    .kpiBox .t { color:#9fb0d0; font-size:12px; }
    .kpiBox .v { font-size:20px; font-weight:900; margin-top:6px; }
    .hint { color:#9fb0d0; font-size:12px; }
  </style>
</head>

<body>
  <h1>Budget Command Center</h1>

  <div class="card">
    <div class="row">
      <div style="min-width:280px;">
        <div class="pill">End Balance (Computed)</div>
        <div id="endBalance" class="kpi">$0.00</div>
        <div id="balanceLine" class="small"></div>
      </div>

      <div style="min-width:220px;">
        <label for="monthSelect">Month view</label>
        <input id="monthSelect" type="month" />
      </div>
    </div>

    <p class="small">
      <b>Starting balance rule:</b> add ONE row in your CSV where either <span class="mono">Name</span> or
      <span class="mono">Memo</span> contains the phrase <span class="mono">starting balance</span>.
      Put the starting balance number in the <span class="mono">Amount</span> column on that same row.
      (Example Name: <span class="mono">STARTING BALANCE</span>)
    </p>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Month Totals (Selected Month)</h3>

    <div class="grid2">
      <div class="kpiBox">
        <div class="t">Starting Balance</div>
        <div id="startBal" class="v">$0.00</div>
        <div id="startBalHint" class="hint"></div>
      </div>

      <div class="kpiBox">
        <div class="t">Net Change (All Transactions)</div>
        <div id="netChange" class="v">$0.00</div>
        <div class="hint">Includes transfers (because they move cash)</div>
      </div>

      <div class="kpiBox">
        <div class="t">Spending (Transfers Excluded)</div>
        <div id="spending" class="v neg">$0.00</div>
        <div class="hint">Better measure of “spend”</div>
      </div>

      <div class="kpiBox">
        <div class="t">Income (Credits)</div>
        <div id="income" class="v pos">$0.00</div>
        <div class="hint">Based on positive amounts</div>
      </div>

      <div class="kpiBox">
        <div class="t">Outflows (Debits)</div>
        <div id="outflows" class="v neg">$0.00</div>
        <div class="hint">Based on negative amounts</div>
      </div>

      <div class="kpiBox">
        <div class="t">Transfers (Net)</div>
        <div id="transfers" class="v">$0.00</div>
        <div class="hint">Net of transfer-labeled items</div>
      </div>
    </div>

    <p class="small">
      If totals still look wrong, it usually means either (1) the CSV doesn’t include all transactions for the month,
      or (2) the “starting balance” row is not dated at (or before) the first real transaction included in the CSV.
    </p>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Import CSV</h3>
    <input type="file" id="fileInput" accept=".csv,text/csv" />
    <div class="btnRow" style="margin-top:10px;">
      <button class="primary" id="importBtn">Import (Add to History)</button>
      <button class="ghost" id="resetBtn">Reset Balance to $0 (Keep Transactions)</button>
      <button class="danger" id="clearBtn">Start Fresh (Delete Everything)</button>
    </div>
    <p id="status" class="small"></p>
    <div id="debug" class="small mono"></div>

    <p class="small">
      <b>Reset options:</b><br/>
      • <b>Reset Balance to $0</b> sets a “reset anchor” so the computed balance starts at 0 from that point forward (keeps history).<br/>
      • <b>Start Fresh</b> deletes all imported data so you can begin from a new CSV.
    </p>
  </div>

  <div class="card">
    <div class="row">
      <h3 style="margin:0;">Transactions (Selected Month)</h3>
      <span id="countPill" class="pill">0 tx</span>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Name</th>
            <th>Memo</th>
            <th>Type</th>
            <th>Category</th>
            <th class="mono">Amount</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

<script>
/* =========================
   Robust CSV parser (quoted commas safe)
========================= */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"') {
      if (inQuotes && next === '"') { cur += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (c === ',' && !inQuotes) {
      row.push(cur);
      cur = "";
    } else if ((c === '\n' || c === '\r') && !inQuotes) {
      if (c === '\r' && next === '\n') i++;
      row.push(cur);
      cur = "";
      if (row.some(cell => cell.trim() !== "")) rows.push(row);
      row = [];
    } else {
      cur += c;
    }
  }
  if (cur.length || row.length) {
    row.push(cur);
    rows.push(row);
  }
  return rows;
}

/* =========================
   Dates & money
========================= */
function parseUSDate(mmddyyyy) {
  const s = (mmddyyyy || "").trim();
  const parts = s.split("/");
  if (parts.length !== 3) return null;
  const mm = parseInt(parts[0], 10);
  const dd = parseInt(parts[1], 10);
  const yyyy = parseInt(parts[2], 10);
  if (!mm || !dd || !yyyy) return null;
  const d = new Date(yyyy, mm - 1, dd);
  if (Number.isNaN(d.getTime())) return null;
  return d;
}
function yyyymmFromDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}
function money(n) {
  return Number(n || 0).toLocaleString("en-US", { style: "currency", currency: "USD" });
}
function parseMoney(value) {
  if (value === null || value === undefined) return null;
  let s = String(value).trim();
  if (!s) return null;

  const isParenNeg = s.startsWith("(") && s.endsWith(")");
  if (isParenNeg) s = s.slice(1, -1);

  s = s.replace(/\$/g, "").replace(/,/g, "").trim();
  const n = Number(s);
  if (Number.isNaN(n)) return null;
  return isParenNeg ? -n : n;
}

/* =========================
   Storage
========================= */
let allTransactions = JSON.parse(localStorage.getItem("transactions") || "[]");

/** A reset anchor lets you keep history but restart balance math.
 *  Stored as: { dateISO: "YYYY-MM-DD", balance: 0 }
 *  If set, we compute balances only from tx >= anchor date and treat starting balance as anchor.balance.
 */
let resetAnchor = JSON.parse(localStorage.getItem("resetAnchor") || "null");

function saveAll() {
  localStorage.setItem("transactions", JSON.stringify(allTransactions));
  if (resetAnchor) localStorage.setItem("resetAnchor", JSON.stringify(resetAnchor));
  else localStorage.removeItem("resetAnchor");
}

/* =========================
   Categorization
========================= */
function isStartingBalanceMarker(name, memo, type) {
  const n = (name || "").toLowerCase();
  const m = (memo || "").toLowerCase();
  const t = (type || "").toLowerCase();
  return n.includes("starting balance") || m.includes("starting balance") || t === "balance";
}

function categorize(type, name, memo, amount) {
  const t = (type || "").toUpperCase();
  const n = (name || "").toUpperCase();
  const m = (memo || "").toUpperCase();

  if (isStartingBalanceMarker(name, memo, type)) return "Starting Balance";

  // basic transfer heuristics
  if (n.includes("PAYMENT TO CREDIT CARD") || n.includes("CREDIT CARD PAYMENT") || n.includes("CREDIT CARD")) return "Transfer";
  if (m.includes("PAYMENT TO CREDIT CARD") || m.includes("CREDIT CARD PAYMENT")) return "Transfer";

  // starter buckets
  if (n.includes("FIDELITY") || n.includes("FID BKG") || m.includes("FIDELITY") || m.includes("FID BKG")) return "Investing";
  if (n.includes("SPECTRUM") || m.includes("SPECTRUM")) return "Utilities";
  if (n.includes("US CELL") || n.includes("USCELL") || m.includes("USCELL")) return "Phone";
  if (n.includes("KWIK TRIP") || n.includes("EXXON") || m.includes("KWIK TRIP") || m.includes("EXXON")) return "Gas";
  if (n.includes("AMAZON") || m.includes("AMAZON")) return "Shopping";
  if (n.includes("PICK N SAVE") || m.includes("PICK N SAVE")) return "Groceries";

  // Income guess
  if (t === "CREDIT" && (n.includes("PAYROLL") || m.includes("PAYROLL") || n.includes("DEPOSIT") || m.includes("DEPOSIT"))) return "Income";

  return amount < 0 ? "Discretionary" : "Other";
}

/* =========================
   Flexible header mapping
========================= */
function indexOfAny(headers, candidates) {
  const upper = headers.map(h => (h || "").trim().toUpperCase());
  for (const c of candidates) {
    const idx = upper.indexOf(c.toUpperCase());
    if (idx >= 0) return idx;
  }
  return -1;
}

/* =========================
   Import
========================= */
async function importCSVFile(file) {
  const text = await file.text();
  const rows = parseCSV(text);
  if (rows.length < 2) throw new Error("CSV looks empty.");

  const header = rows[0].map(h => (h || "").trim());
  const iDate = indexOfAny(header, ["Date", "Posting Date", "Transaction Date"]);
  const iType = indexOfAny(header, ["Transaction", "Type"]);
  const iName = indexOfAny(header, ["Name", "Merchant", "Description"]);
  const iMemo = indexOfAny(header, ["Memo", "Details", "Note"]);
  const iAmount = indexOfAny(header, ["Amount", "Transaction Amount"]);

  if (iDate < 0 || iName < 0 || iAmount < 0) {
    throw new Error("Missing required columns. Need at least: Date + Name/Merchant + Amount.");
  }

  let added = 0, skipped = 0, failed = 0;
  const debugRows = [];

  for (const r of rows.slice(1)) {
    try {
      const dateStr = (r[iDate] ?? "").trim();
      const type = (iType >= 0 ? (r[iType] ?? "").trim() : "").toUpperCase();
      const name = (r[iName] ?? "").trim();
      const memo = (iMemo >= 0 ? (r[iMemo] ?? "").trim() : "");
      const amount = parseMoney(r[iAmount]);

      const d = parseUSDate(dateStr);
      if (!d || amount === null) { failed++; continue; }

      const month = yyyymmFromDate(d);
      const dateISO = d.toISOString().slice(0, 10);

      const category = categorize(type, name, memo, amount);

      // Dedup: date + name + memo + amount + type
      const key = `${dateISO}|${name}|${memo}|${amount.toFixed(2)}|${type || ""}`;
      const exists = allTransactions.some(t => t.key === key);
      if (exists) { skipped++; continue; }

      const record = { key, dateISO, month, type, name, memo, amount, category };
      allTransactions.push(record);
      added++;

      if (debugRows.length < 4) debugRows.push(record);
    } catch {
      failed++;
    }
  }

  saveAll();
  return { added, skipped, failed, debugRows };
}

/* =========================
   Dashboard
========================= */
const els = {
  monthSelect: document.getElementById("monthSelect"),
  endBalance: document.getElementById("endBalance"),
  balanceLine: document.getElementById("balanceLine"),

  startBal: document.getElementById("startBal"),
  startBalHint: document.getElementById("startBalHint"),
  netChange: document.getElementById("netChange"),
  spending: document.getElementById("spending"),
  income: document.getElementById("income"),
  outflows: document.getElementById("outflows"),
  transfers: document.getElementById("transfers"),

  fileInput: document.getElementById("fileInput"),
  importBtn: document.getElementById("importBtn"),
  resetBtn: document.getElementById("resetBtn"),
  clearBtn: document.getElementById("clearBtn"),
  status: document.getElementById("status"),
  debug: document.getElementById("debug"),

  countPill: document.getElementById("countPill"),
  tableBody: document.getElementById("tableBody")
};

function getSelectedMonth() {
  return els.monthSelect.value || yyyymmFromDate(new Date());
}

function updateDashboard() {
  const sel = getSelectedMonth();

  // Apply reset anchor for balance math (optional)
  const balanceScopeTx = resetAnchor
    ? allTransactions.filter(t => t.dateISO >= resetAnchor.dateISO)
    : allTransactions.slice();

  const monthTx = allTransactions.filter(t => t.month === sel);

  // Starting balance row(s) for this month: look for marker in NAME or MEMO or Type=Balance
  const startRows = monthTx
    .filter(t => t.category === "Starting Balance")
    .sort((a,b) => a.dateISO > b.dateISO ? 1 : -1);

  // For month totals, exclude synthetic starting balance rows
  const realTx = monthTx.filter(t => t.category !== "Starting Balance");

  const totalIncome = realTx.filter(t => t.amount > 0).reduce((s,t)=>s+t.amount,0);
  const totalOutflows = realTx.filter(t => t.amount < 0).reduce((s,t)=>s+Math.abs(t.amount),0);

  const transferOut = realTx.filter(t => t.category === "Transfer" && t.amount < 0).reduce((s,t)=>s+Math.abs(t.amount),0);
  const transferIn  = realTx.filter(t => t.category === "Transfer" && t.amount > 0).reduce((s,t)=>s+t.amount,0);
  const transferNet = transferIn - transferOut;

  const spending = realTx
    .filter(t => t.amount < 0)
    .filter(t => t.category !== "Transfer")
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const netChangeAll = realTx.reduce((s,t)=>s + Number(t.amount || 0), 0);

  // Month-level balance: if resetAnchor exists and is within month, we use it; otherwise we use month starting balance row.
  let startBal = null;
  let startHint = "";

  const monthStartISO = `${sel}-01`;

  if (resetAnchor && resetAnchor.dateISO >= monthStartISO && resetAnchor.dateISO <= `${sel}-31`) {
    // reset anchor falls in this month
    startBal = resetAnchor.balance;
    startHint = `Using reset anchor on ${resetAnchor.dateISO} (balance starts at ${money(resetAnchor.balance)})`;
  } else if (startRows.length) {
    startBal = startRows[0].amount;
    startHint = `Using “starting balance” row dated ${startRows[0].dateISO}`;
  } else if (resetAnchor && resetAnchor.dateISO < monthStartISO) {
    // If reset anchor is earlier than this month and there is no month start row,
    // we cannot infer the true start of month without prior month close, so we show missing.
    startBal = null;
    startHint = `No starting balance row found for ${sel}. Add one line with “starting balance” in Name or Memo.`;
  } else {
    startBal = null;
    startHint = `No starting balance row found for ${sel}. Add one line with “starting balance” in Name or Memo.`;
  }

  // End balance for month (computed) only if startBal exists
  let endBal = null;
  if (startBal !== null) endBal = startBal + netChangeAll;

  // Render totals
  els.income.textContent = money(totalIncome);
  els.outflows.textContent = money(totalOutflows);
  els.spending.textContent = money(spending);
  els.transfers.textContent = money(transferNet);
  els.netChange.textContent = money(netChangeAll);

  // Render balance
  if (startBal === null) {
    els.startBal.textContent = "(missing)";
    els.startBalHint.textContent = startHint;
    els.endBalance.textContent = "(missing)";
    els.endBalance.style.color = "#9fb0d0";
    els.balanceLine.textContent = "Add a row where Name or Memo contains “starting balance” and Amount is the starting balance.";
  } else {
    els.startBal.textContent = money(startBal);
    els.startBalHint.textContent = startHint;
    els.endBalance.textContent = money(endBal);
    els.endBalance.style.color = (endBal >= 0 ? "#6bff95" : "#ff6b6b");
    els.balanceLine.textContent = `Start: ${money(startBal)} • Net change: ${money(netChangeAll)} • End: ${money(endBal)}`;
  }

  // Table
  els.countPill.textContent = `${monthTx.length} tx`;
  els.tableBody.innerHTML = "";

  monthTx
    .slice()
    .sort((a,b) => a.dateISO < b.dateISO ? 1 : -1)
    .slice(0, 400)
    .forEach(t => {
      const row = document.createElement("tr");
      const amtClass = t.amount >= 0 ? "pos" : "neg";
      row.innerHTML = `
        <td class="mono">${t.dateISO}</td>
        <td>${t.name}</td>
        <td>${t.memo || ""}</td>
        <td class="mono">${t.type || ""}</td>
        <td><span class="pill">${t.category}</span></td>
        <td class="mono ${amtClass}">${money(t.amount)}</td>
      `;
      els.tableBody.appendChild(row);
    });
}

/* =========================
   Reset / clear controls
========================= */
function resetBalanceToZero() {
  // Create/reset anchor at the earliest date of currently selected month OR today if no tx in month.
  const sel = getSelectedMonth();
  const monthTx = allTransactions.filter(t => t.month === sel).sort((a,b)=>a.dateISO > b.dateISO ? 1 : -1);
  const anchorDateISO = monthTx.length ? monthTx[0].dateISO : new Date().toISOString().slice(0,10);

  resetAnchor = { dateISO: anchorDateISO, balance: 0 };

  // Also remove any starting-balance rows from the selected month so they don’t keep affecting the math (optional but helpful)
  allTransactions = allTransactions.filter(t => !(t.month === sel && t.category === "Starting Balance"));

  saveAll();
  els.status.textContent = `Balance reset: starting at $0 on ${anchorDateISO}. (History kept)`;
  updateDashboard();
}

function clearAll() {
  if (!confirm("Start fresh? This deletes ALL imported data and resets everything.")) return;
  allTransactions = [];
  resetAnchor = null;
  localStorage.clear();
  els.status.textContent = "Deleted everything. Start by importing a new CSV.";
  els.debug.textContent = "";
  els.monthSelect.value = yyyymmFromDate(new Date());
  updateDashboard();
}

/* =========================
   Wire UI
========================= */
els.monthSelect.addEventListener("change", updateDashboard);
els.clearBtn.addEventListener("click", clearAll);
els.resetBtn.addEventListener("click", () => {
  if (!confirm("Reset balance to $0 (keeps transaction history)?")) return;
  resetBalanceToZero();
});

els.importBtn.addEventListener("click", async () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) { els.status.textContent = "Pick a CSV file first."; return; }

  els.status.textContent = "Importing…";
  els.debug.textContent = "";

  try {
    const res = await importCSVFile(f);
    els.status.textContent = `Imported. Added ${res.added}, skipped ${res.skipped} dupes, failed ${res.failed}.`;

    if (res.debugRows.length) {
      els.debug.textContent =
        "Parsed sample rows:\n" +
        res.debugRows.map(r => `${r.dateISO} | ${r.name} | ${r.memo || ""} | ${r.amount} | ${r.category}`).join("\n");
    } else {
      els.debug.textContent = "No rows parsed. If this happens, paste your CSV header row here and I’ll map it.";
    }

    updateDashboard();
  } catch (e) {
    els.status.textContent = `Import failed: ${e.message || e}`;
  } finally {
    els.fileInput.value = "";
  }
});

/* =========================
   Init
========================= */
(function init() {
  els.monthSelect.value = yyyymmFromDate(new Date());
  updateDashboard();
})();
</script>

</body>
</html>
