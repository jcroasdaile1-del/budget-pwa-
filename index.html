<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <title>Budget Command Center</title>

  <style>
    body { margin:0; font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif; background:#0b1220; color:#e8eefc; padding:16px; }
    h1 { font-size:18px; margin:0 0 12px; }
    .card { background:#121a2b; padding:16px; border-radius:12px; margin-bottom:16px; border:1px solid #24314f; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
    button { padding:10px 14px; border-radius:10px; border:none; font-weight:900; cursor:pointer; }
    .primary { background:#64d2ff; color:#0b1220; }
    .danger { background:#ff6b6b; color:#fff; }
    .ghost { background:#0f1726; color:#e8eefc; border:1px solid #24314f; }
    input, select { padding:10px; border-radius:10px; border:1px solid #24314f; background:#0f1726; color:#e8eefc; width:100%; }
    label { font-size:12px; color:#9fb0d0; display:block; margin-bottom:6px; }
    table { width:100%; font-size:12px; border-collapse:collapse; }
    th, td { padding:8px 6px; border-bottom:1px solid #24314f; vertical-align:top; }
    th { color:#9fb0d0; text-align:left; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #24314f; border-radius:999px; color:#9fb0d0; font-size:11px; }
    .pos { color:#6bff95; }
    .neg { color:#ff6b6b; }
    .small { font-size:12px; color:#9fb0d0; line-height:1.4; margin:8px 0 0; }
    .kpi { font-size:34px; font-weight:950; margin:6px 0 0; letter-spacing:-.5px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap:10px; }
    .grid3 { display:grid; grid-template-columns: 1fr; gap:10px; }
    @media(min-width:820px){
      .grid2 { grid-template-columns: 1fr 1fr; }
      .grid3 { grid-template-columns: 1fr 1fr 1fr; }
    }
    .kpiBox { background:#0f1726; border:1px solid #24314f; border-radius:12px; padding:12px; }
    .kpiBox .t { color:#9fb0d0; font-size:12px; }
    .kpiBox .v { font-size:20px; font-weight:900; margin-top:6px; }
    .hint { color:#9fb0d0; font-size:12px; }
    .warn { color:#ffd36b; }
    details summary { cursor:pointer; color:#e8eefc; font-weight:800; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; background:#0f1726; border:1px solid #24314f; font-size:11px; color:#9fb0d0; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #24314f; background:#0f1726; font-size:12px; color:#e8eefc; margin:4px 6px 0 0; }
    .right { text-align:right; }
    canvas { max-width:100%; background:#0f1726; border:1px solid #24314f; border-radius:12px; }
    .inline { display:flex; gap:10px; flex-wrap:wrap; }
    .inline > div { flex: 1; min-width: 220px; }
  
  /* ===== Fidelity Phase 2 (additive) ===== */
  .bigKpi2 { background:#0f1726; border:1px solid #24314f; border-radius:12px; padding:16px; text-align:center; }
  .bigKpi2 .t { color:#9fb0d0; font-size:13px; }
  .bigKpi2 .v { font-size:40px; font-weight:950; margin-top:8px; letter-spacing:-.6px; }
  .bigKpi2 .s { font-size:12px; color:#9fb0d0; margin-top:6px; }
  .miniGrid2 { display:grid; grid-template-columns: 1fr; gap:10px; }
  @media(min-width:820px){ .miniGrid2 { grid-template-columns: 1fr 1fr; } }

</style>
</head>

<body>
  <h1>Budget Command Center</h1>

  <div class="card">
    <div class="row">
      <div style="min-width:340px;">
        <div class="pill" id="scopePill">Scope</div>
        <div id="topLine" class="kpi">$0.00</div>
        <div id="topSub" class="small"></div>
        <div id="balanceSub" class="small"></div>
      </div>

      <div style="min-width:340px;">
        <label for="viewMode">View mode</label>
        <select id="viewMode">
          <option value="range" selected>Date range (auto from CSV)</option>
          <option value="month">Month</option>
          <option value="all">All time</option>
        </select>

        <div id="rangeWrap" style="margin-top:10px;">
          <div class="row">
            <div style="min-width:150px; flex:1;">
              <label for="rangeStart">Start</label>
              <input id="rangeStart" type="date" />
            </div>
            <div style="min-width:150px; flex:1;">
              <label for="rangeEnd">End</label>
              <input id="rangeEnd" type="date" />
            </div>
          </div>
          <div class="btnRow" style="margin-top:8px;">
            <button class="ghost" id="rangeToAllDataBtn">Full history range</button>
            <button class="ghost" id="rangeLast90Btn">Last 90 days</button>
            <button class="ghost" id="rangeThisMonthBtn">This month</button>
          </div>
        </div>

        <div id="monthWrap" style="margin-top:10px; display:none;">
          <label for="monthSelect">Month</label>
          <input id="monthSelect" type="month" />
        </div>

        <div style="margin-top:10px;">
          <label for="chartMode">Pie chart</label>
          <select id="chartMode">
            <option value="spending" selected>Spending by Category</option>
            <option value="cashflow">Cashflow: Inflows vs Outflows (Transfers excluded)</option>
          </select>
        </div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <canvas id="pieCanvas" width="900" height="360"></canvas>
      <div id="pieSummary" class="small"></div>
    </div>

    <p class="small">
      <b>Running balance:</b> Uses the most recent marker row (Transaction=Balance OR Name/Memo contains “starting balance”)
      on/before the scope end date, then sums transactions forward to the end date.
      If you ever want to restart the running balance, add a newer marker row with your new anchor.
    </p>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Totals (Current Scope)</h3>

    <div class="grid3">
      <div class="kpiBox">
        <div class="t">Income (Credits, Transfers Excluded)</div>
        <div id="income" class="v pos">$0.00</div>
        <div class="hint">Sum of positive amounts excluding transfers</div>
      </div>

      <div class="kpiBox">
        <div class="t">Outflows (Debits, Transfers Excluded)</div>
        <div id="outflows" class="v neg">$0.00</div>
        <div class="hint">Sum of absolute negatives excluding transfers</div>
      </div>

      <div class="kpiBox">
        <div class="t">Spending (Transfers Excluded)</div>
        <div id="spending" class="v neg">$0.00</div>
        <div class="hint">Debits excluding transfers (includes credit-card purchases)</div>
      </div>

      <div class="kpiBox">
        <div class="t">Transfers (Net)</div>
        <div id="transfers" class="v">$0.00</div>
        <div class="hint">Net of transfer-labeled items</div>
      </div>

      <div class="kpiBox">
        <div class="t">Net Change (All Tx)</div>
        <div id="netChange" class="v">$0.00</div>
        <div class="hint">Sum of amounts (excludes marker rows)</div>
      </div>

      <div class="kpiBox">
        <div class="t">Running Balance (Computed)</div>
        <div id="balanceBox" class="v">$0.00</div>
        <div id="balanceHint" class="hint"></div>
      </div>

      <div class="kpiBox">
        <div class="t">Checking Account Balance</div>
        <div id="checkingBalanceBox" class="v">$0.00</div>
        <div id="checkingBalanceHint" class="hint"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <details open>
      <summary>Credit Cards (Scope)</summary>

      <div class="grid2" style="margin-top:12px;">
        <div class="kpiBox">
          <div class="t">Per-card KPIs</div>
          <div id="ccKpiLine" class="v">—</div>
          <div id="ccTableWrap" class="small"></div>
        </div>

        <div class="kpiBox">
          <div class="t">Payoff Planner (uses saved balances/APR/min)</div>
          <div id="payoffHeadline" class="v">—</div>
          <div id="payoffDetails" class="small"></div>
        </div>
      </div>

      <details style="margin-top:12px;">
        <summary>Card Settings (limits, APR, balances)</summary>

        <p class="small">
          These settings are saved in your browser (localStorage). Add/update balances & limits once, and the dashboard will show utilization + payoff guidance.
        </p>

        <div id="cardSettingsWrap" style="margin-top:10px;"></div>

        <div class="btnRow" style="margin-top:10px;">
          <button class="ghost" id="addCardBtn">Add Card Profile</button>
          <button class="primary" id="saveCardSettingsBtn">Save Card Settings</button>
        </div>

        <div class="btnRow" style="margin-top:10px;">
          <button class="ghost" id="selectAllCardsBtn">Select All</button>
          <label class="small" style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="trashCardsAlsoTxChk" />
            Also move selected cards&#39; transactions to Trash
          </label>
          <button class="danger" id="trashSelectedCardsBtn" disabled>Move Selected to Trash</button>
        </div>

        <details style="margin-top:12px;">
          <summary>Credit Cards Trash <span id="cardsTrashCount" class="pill">0</span></summary>
          <div class="small hint" style="margin-top:6px;">Deleted card profiles (and optionally their transactions) stay here until you restore them or clear trash.</div>
          <div id="cardsTrashWrap" style="overflow:auto; margin-top:10px;"></div>
          <div class="btnRow" style="margin-top:10px;">
            <button class="danger" id="clearCardsTrashBtn" disabled>Clear Trash</button>
          </div>
        </details>

        <div id="cardSettingsStatus" class="small"></div>
      </details>
    </details>
  </div>

  <!-- =========================================================
     INVESTMENTS (FIDELITY) MODULE – PHASE 1 (ADDITIVE ONLY)
========================================================= -->
<div class="card">
  <h3 style="margin:0 0 12px;">Investments (Fidelity)</h3>

  <div class="bigKpi">
    <div class="t">Total Invested (All-Time)</div>
    <div id="invLifetime" class="v">$0.00</div>
  </div>

  <div class="grid3" style="margin-top:14px;">
    <div class="kpiBox">
      <div class="t">Contributions (Scope)</div>
      <div id="invContrib" class="v">$0.00</div>
    </div>

    <div class="kpiBox">
      <div class="t">Withdrawals (Scope)</div>
      <div id="invWithdraw" class="v">$0.00</div>
    </div>

    <div class="kpiBox">
      <div class="t">Net Investing (Scope)</div>
      <div id="invNet" class="v">$0.00</div>
    </div>

    <div class="kpiBox">
      <div class="t">Last Contribution</div>
      <div id="invLast" class="v">—</div>
    </div>

    <div class="kpiBox">
      <div class="t">Contribution Pattern</div>
      <div id="invPattern" class="v">—</div>
    </div>

    <div class="kpiBox">
      <div class="t">Monthly Contributions (All-Time)</div>
      <div id="invMonthly" class="small"></div>
      <hr style="border:none; border-top:1px solid #24314f; margin:14px 0;">

      <details open style="margin-top:6px;">
        <summary>Portfolio Snapshot (Holdings)</summary>

        <div class="small" style="margin-top:8px;">
          Import your Fidelity <span class="mono">Portfolio Positions</span> CSV to track holdings, allocation, and unrealized gains/losses.
          Cash (<span class="mono">FCASH**</span>) is included.
        </div>

        <div class="kpiBox" style="margin-top:10px;">
          <div class="row" style="align-items:flex-end;">
            <div style="flex:1; min-width:260px;">
              <label for="fidelityPositionsFile">Fidelity Positions CSV</label>
              <input type="file" id="fidelityPositionsFile" accept=".csv,text/csv" />
              <div class="hint" style="margin-top:6px;">Example filename: <span class="mono">Portfolio_Positions_Feb-15-2026.csv</span></div>
            </div>

            <div style="flex:1; min-width:220px;">
              <label for="fidelityAsOfDate">As-of date (optional)</label>
              <input id="fidelityAsOfDate" type="date" />
              <div class="hint" style="margin-top:6px;">If blank, the app will try to detect from filename.</div>
            </div>

            <div style="min-width:220px;">
              <button class="primary" id="importFidelityPositionsBtn" style="width:100%;">Import Holdings Snapshot</button>
              <div id="fidelityImportStatus" class="small" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>

        <div class="bigKpi2" style="margin-top:12px;">
          <div class="t">Portfolio Value (Latest Snapshot)</div>
          <div id="fidPortfolioValue" class="v">$0.00</div>
          <div id="fidPortfolioSub" class="s">No snapshots yet.</div>
        </div>

        <div class="miniGrid2" style="margin-top:12px;">
          <div>
            <canvas id="fidPieCanvas" width="900" height="360"></canvas>
            <div id="fidPieSummary" class="small"></div>
          </div>

          <div class="kpiBox" style="overflow:auto;">
            <div class="t">Holdings (Latest Snapshot)</div>
            <div id="fidHoldingsTable" class="small" style="margin-top:8px;"></div>
          </div>
        </div>

        <details style="margin-top:12px;">
          <summary>Snapshot History <span id="fidSnapCount" class="pill">0</span></summary>
          <div class="small hint" style="margin-top:6px;">Snapshots are saved in your browser (localStorage). Delete old ones to keep things tidy.</div>
          <div id="fidSnapHistory" style="overflow:auto; margin-top:10px;"></div>
        </details>
      </details>

    </div>
  </div>
</div>


<div class="card">
    <details open>
      <summary>Smart Insights</summary>

      <div class="grid2" style="margin-top:12px;">
        <div class="kpiBox">
          <div class="t">Recurring bills / subscriptions detected</div>
          <div id="recurringCount" class="v">0</div>
          <div id="recurringList" class="small"></div>
        </div>

        <div class="kpiBox">
          <div class="t">Paycheck pattern + overtime spikes</div>
          <div id="paycheckSummary" class="v">—</div>
          <div id="paycheckList" class="small"></div>
        </div>
      </div>

      <div class="kpiBox" style="margin-top:12px;">
        <div class="t">Reconciliation (import quality)</div>
        <div id="reconLine" class="v">—</div>
        <div id="reconDetails" class="small"></div>
      </div>
    </details>
  </div>

  <div class="card">
    <details>
      <summary>Rules: teach the app how to categorize merchants</summary>

      <p class="small">
        Add rules like: <span class="mono">"PMI of Greater M"</span> → <span class="mono">HOA</span>.
        Rules are applied top-to-bottom (first match wins).
      </p>

      <div class="grid2">
        <div>
          <label>Merchant contains (case-insensitive)</label>
          <input id="ruleContains" placeholder='e.g. web authorized pmt pmi of greater m' />
        </div>
        <div>
          <label>Category</label>
          <select id="ruleCategory">
            <option>Groceries</option>
            <option>Gas</option>
            <option>Utilities</option>
            <option>Phone</option>
            <option>Mortgage</option>
            <option>HOA</option>
            <option>Car Payment</option>
            <option>Insurance</option>
            <option>Subscriptions</option>
            <option>Dining</option>
            <option>Shopping</option>
            <option>Kids</option>
            <option>Medical</option>
            <option>Travel</option>
            <option>Investing</option>
            <option>Transfer</option>
            <option>Income</option>
            <option>Other</option>
          </select>
        </div>
      </div>

      <div class="btnRow" style="margin-top:10px;">
        <button class="primary" id="addRuleBtn">Add Rule</button>
        <button class="ghost" id="reapplyRulesBtn">Reapply Rules to All Transactions</button>
        <button class="ghost" id="selectAllRulesBtn">Select All</button>
        <button class="danger" id="trashSelectedRulesBtn" disabled>Move Selected to Trash</button>
        <button class="danger" id="clearRulesBtn">Move All Rules to Trash</button>
      </div>

      <div id="rulesTableWrap" style="overflow:auto; margin-top:12px;"></div>

      <details style="margin-top:12px;">
        <summary>Rules Trash <span id="rulesTrashCount" class="pill">0</span></summary>
        <div class="small hint" style="margin-top:6px;">Deleted rules stay here (even after refresh) until you restore them or clear trash.</div>
        <div id="rulesTrashWrap" style="overflow:auto; margin-top:10px;"></div>
        <div class="btnRow" style="margin-top:10px;">
          <button class="danger" id="clearRulesTrashBtn" disabled>Clear Trash</button>
        </div>
      </details>
    </details>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Import CSV</h3>
    <input type="file" id="fileInput" accept=".csv,text/csv" />

    <div class="inline" style="margin-top:10px;">
      <div>
        <label for="importAs">Import as</label>
        <select id="importAs">
          <option value="auto" selected>Auto-detect (from filename)</option>
          <option value="checking">Checking account</option>
          <option value="credit">Credit card</option>
        </select>
      </div>

      <div id="importCardWrap" style="display:none;">
        <label for="importCard">Which card?</label>
        <select id="importCard"></select>
        <div class="hint" style="margin-top:6px;">Tip: filename like “Credit Card - 9746_...” will auto-pick 9746.</div>
      </div>
    </div>

    <div class="btnRow" style="margin-top:10px;">
      <button class="primary" id="importBtn">Import (Add to History)</button>
      <button class="ghost" id="removeMarkersBtn">Remove ALL Starting Balance Rows</button>
      <button class="danger" id="clearBtn">Start Fresh (Delete Everything)</button>
    </div>

    <p id="status" class="small"></p>
    <div id="debug" class="small mono"></div>
  </div>

  <div class="card">
    <div class="row">
      <h3 style="margin:0;">Transactions (Current Scope)</h3>
      <span id="countPill" class="pill">0 rows</span>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Acct</th>
            <th>Transaction</th>
            <th>Name</th>
            <th>Memo</th>
            <th>Category</th>
            <th class="mono right">Amount</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

<script>
/* =========================================================
   0) Storage + State
========================================================= */
let allTransactions = JSON.parse(localStorage.getItem("transactions") || "[]");
let userRules = JSON.parse(localStorage.getItem("userRules") || "[]");
let importMeta = JSON.parse(localStorage.getItem("importMeta") || "[]");
let cardProfiles = JSON.parse(localStorage.getItem("cardProfiles") || "[]");
let trashStore = JSON.parse(localStorage.getItem("trashStore") || "{\"rules\":[],\"cards\":[],\"cardTx\":[]}");

// Seed defaults (Jim/Mara) if not present
function ensureDefaultCards() {
  const has9746 = cardProfiles.some(c => c && c.last4 === "9746");
  const has1289 = cardProfiles.some(c => c && c.last4 === "1289");
  if (!has9746) cardProfiles.push({ id:"cc-9746", name:"Jim's Card", last4:"9746", limit:null, apr:null, minPayment:null, dueDay:null, balance:null });
  if (!has1289) cardProfiles.push({ id:"cc-1289", name:"Mara's Card", last4:"1289", limit:null, apr:null, minPayment:null, dueDay:null, balance:null });
}

function saveAll() {
  localStorage.setItem("transactions", JSON.stringify(allTransactions));
  localStorage.setItem("userRules", JSON.stringify(userRules));
  localStorage.setItem("importMeta", JSON.stringify(importMeta));
  localStorage.setItem("cardProfiles", JSON.stringify(cardProfiles));
  localStorage.setItem("trashStore", JSON.stringify(trashStore));
}


/* =========================================================
   Trash helpers (rules + card profiles + optional card transactions)
========================================================= */
function makeTrashId(prefix="t") {
  return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function ensureTrashStoreShape() {
  if (!trashStore || typeof trashStore !== "object") trashStore = { rules: [], cards: [], cardTx: [] };
  if (!Array.isArray(trashStore.rules)) trashStore.rules = [];
  if (!Array.isArray(trashStore.cards)) trashStore.cards = [];
  if (!Array.isArray(trashStore.cardTx)) trashStore.cardTx = [];
}

function formatDateTime(iso) {
  try {
    return new Date(iso).toLocaleString();
  } catch {
    return String(iso || "");
  }
}

function moveRulesToTrash(indices) {
  ensureTrashStoreShape();
  const uniq = Array.from(new Set(indices.map(Number))).filter(i => i >= 0 && i < userRules.length);
  if (!uniq.length) return;
  if (!confirm(`Move ${uniq.length} rule(s) to Trash?`)) return;

  // Preserve order by removing highest index first
  uniq.sort((a,b) => b-a);
  for (const i of uniq) {
    const rule = userRules[i];
    const trashId = makeTrashId("rule");
    trashStore.rules.push({ trashId, deletedAt: new Date().toISOString(), rule });
    userRules.splice(i, 1);
  }
  saveAll();
  updateRulesTable();
  renderRulesTrash();
  recategorizeAll();
  updateDashboard();
}

function restoreRuleFromTrash(trashId) {
  ensureTrashStoreShape();
  const entry = trashStore.rules.find(x => x.trashId === trashId);
  if (!entry) return;
  userRules.push(entry.rule);
  trashStore.rules = trashStore.rules.filter(x => x.trashId !== trashId);
  saveAll();
  updateRulesTable();
  renderRulesTrash();
  recategorizeAll();
  updateDashboard();
}

function moveCardsToTrash(cardIndices, alsoTx=false) {
  ensureTrashStoreShape();
  const uniq = Array.from(new Set(cardIndices.map(Number))).filter(i => i >= 0 && i < cardProfiles.length);
  if (!uniq.length) return;

  const msg = alsoTx
    ? `Move ${uniq.length} card profile(s) AND their imported transactions to Trash?`
    : `Move ${uniq.length} card profile(s) to Trash? (Transactions remain)`;
  if (!confirm(msg)) return;

  // Remove highest index first to avoid reindexing issues
  uniq.sort((a,b) => b-a);

  for (const i of uniq) {
    const card = cardProfiles[i];
    const cardTrashId = makeTrashId("card");
    let txTrashId = null;

    if (alsoTx && card?.id) {
      const txToTrash = allTransactions.filter(t => t.accountId === card.id);
      if (txToTrash.length) {
        txTrashId = makeTrashId("ctx");
        trashStore.cardTx.push({ trashId: txTrashId, deletedAt: new Date().toISOString(), cardId: card.id, transactions: txToTrash });
        // Remove those transactions from main set
        allTransactions = allTransactions.filter(t => t.accountId !== card.id);
      }
    }

    trashStore.cards.push({ trashId: cardTrashId, deletedAt: new Date().toISOString(), card, txTrashId });
    cardProfiles.splice(i, 1);
  }

  saveAll();
  populateImportCardDropdown();
  renderCardSettings();
  renderCardsTrash();
  updateDashboard();
}

function restoreCardFromTrash(cardTrashId) {
  ensureTrashStoreShape();
  const entry = trashStore.cards.find(x => x.trashId === cardTrashId);
  if (!entry) return;

  // Restore profile
  cardProfiles.push(entry.card);

  // Restore tx bundle if it exists
  if (entry.txTrashId) {
    const txEntry = (trashStore.cardTx || []).find(x => x.trashId === entry.txTrashId);
    if (txEntry?.transactions?.length) {
      allTransactions = allTransactions.concat(txEntry.transactions);
      trashStore.cardTx = (trashStore.cardTx || []).filter(x => x.trashId !== entry.txTrashId);
    }
  }

  // Remove from trash
  trashStore.cards = trashStore.cards.filter(x => x.trashId !== cardTrashId);

  saveAll();
  populateImportCardDropdown();
  renderCardSettings();
  renderCardsTrash();
  updateDashboard();
}

/* =========================================================
   1) Utilities: CSV parsing, money, dates
========================================================= */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"') {
      if (inQuotes && next === '"') { cur += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (c === ',' && !inQuotes) {
      row.push(cur); cur = "";
    } else if ((c === '\n' || c === '\r') && !inQuotes) {
      if (c === '\r' && next === '\n') i++;
      row.push(cur); cur = "";
      if (row.some(cell => cell.trim() !== "")) rows.push(row);
      row = [];
    } else {
      cur += c;
    }
  }
  if (cur.length || row.length) { row.push(cur); rows.push(row); }
  return rows;
}

function parseMoney(value) {
  if (value === null || value === undefined) return null;
  let s = String(value).trim();
  if (!s) return null;

  const isParenNeg = s.startsWith("(") && s.endsWith(")");
  if (isParenNeg) s = s.slice(1, -1);

  s = s.replace(/\$/g, "").replace(/,/g, "").trim();
  const n = Number(s);
  if (Number.isNaN(n)) return null;
  return isParenNeg ? -n : n;
}

function money(n) {
  return Number(n || 0).toLocaleString("en-US", { style: "currency", currency: "USD" });
}

function moneySigned(n) {
  const v = Number(n || 0);
  const prefix = v > 0 ? "+" : "";
  return prefix + money(v);
}

function parseDateSmart(value) {
  const s = (value || "").trim();
  if (!s) return null;

  // ISO yyyy-mm-dd
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
    const d = new Date(s + "T00:00:00");
    if (!Number.isNaN(d.getTime())) return d;
  }

  // US mm/dd/yyyy
  const parts = s.split("/");
  if (parts.length === 3) {
    const mm = parseInt(parts[0], 10);
    const dd = parseInt(parts[1], 10);
    const yyyy = parseInt(parts[2], 10);
    if (mm && dd && yyyy) {
      const d = new Date(yyyy, mm - 1, dd);
      if (!Number.isNaN(d.getTime())) return d;
    }
  }

  // fallback
  const d = new Date(s);
  if (!Number.isNaN(d.getTime())) return d;
  return null;
}

function yyyymmFromDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}

function indexOfAny(headers, candidates) {
  const upper = headers.map(h => (h || "").trim().toUpperCase());
  for (const c of candidates) {
    const idx = upper.indexOf(c.toUpperCase());
    if (idx >= 0) return idx;
  }
  return -1;
}

function maxDateISO(records) {
  if (!records.length) return null;
  return records.reduce((max, r) => (r.dateISO > max ? r.dateISO : max), records[0].dateISO);
}

function minDateISO(records) {
  if (!records.length) return null;
  return records.reduce((min, r) => (r.dateISO < min ? r.dateISO : min), records[0].dateISO);
}

function daysBetweenISO(aISO, bISO) {
  const a = new Date(aISO + "T00:00:00");
  const b = new Date(bISO + "T00:00:00");
  return Math.round((b - a) / (1000 * 60 * 60 * 24));
}

function isoAddDays(dateISO, n) {
  const d = new Date(dateISO + "T00:00:00");
  d.setDate(d.getDate() + n);
  return d.toISOString().slice(0, 10);
}

function escapeHtml(s) {
  return String(s || "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#39;");
}

function detectLast4FromFilename(name) {
  const m = String(name || "").match(/(\d{4})/);
  return m ? m[1] : null;
}

function getCardByLast4(last4) {
  return cardProfiles.find(c => c && String(c.last4) === String(last4));
}

function getOrCreateCardProfile(last4, defaultName) {
  const existing = getCardByLast4(last4);
  if (existing) return existing;
  const profile = {
    id: `cc-${last4}`,
    name: defaultName || `Card ${last4}`,
    last4: String(last4),
    limit: null,
    apr: null,
    minPayment: null,
    dueDay: null,
    balance: null
  };
  cardProfiles.push(profile);
  saveAll();
  return profile;
}

function accountLabel(t) {
  if (!t) return "";
  if (t.accountType === "credit") return `CC ${t.accountLast4 || ""}`.trim();
  return "Checking";
}

/* =========================================================
   2) Normalization + Categorization Engine
========================================================= */
function normalizeMerchant(name, memo) {
  const base = (name || "").replace(/\s+/g, " ").trim();
  const m = (memo || "").replace(/\s+/g, " ").trim();
  return (base || m || "").trim();
}

function isMarkerRow(txType, name, memo) {
  const t = (txType || "").toLowerCase().trim();
  const n = (name || "").toLowerCase();
  const m = (memo || "").toLowerCase();
  return (t === "balance") || n.includes("starting balance") || m.includes("starting balance");
}

function applyRulesCategory(merchant) {
  const m = (merchant || "").toLowerCase();
  for (const rule of userRules) {
    if (!rule || !rule.contains || !rule.category) continue;
    if (m.includes(String(rule.contains).toLowerCase())) return rule.category;
  }
  return null;
}

// Model A transfer detection:
// - Checking: "PAYMENT TO CREDIT CARD" (your 9746 / 1289 strings)
// - Credit card: "MOBILE PAYMENT THANK YOU"
function isTransferByText(merchant, memo) {
  const n = (merchant || "").toUpperCase();
  const m = (memo || "").toUpperCase();

  // Checking → credit card payments
  if (n.includes("MOBILE BANKING PAYMENT TO CREDIT CARD") || m.includes("MOBILE BANKING PAYMENT TO CREDIT CARD")) return true;

  // Common credit card payment wording
  if (n.includes("PAYMENT TO CREDIT CARD") || m.includes("PAYMENT TO CREDIT CARD")) return true;
  if (n.includes("CREDIT CARD PAYMENT") || m.includes("CREDIT CARD PAYMENT")) return true;

  // Variants seen in many bank exports
  if ((n.includes("WEB AUTHORIZED PMT") && n.includes("CARD")) || (m.includes("WEB AUTHORIZED PMT") && m.includes("CARD"))) return true;
  if ((n.includes("ELECTRONIC WITHDRAWAL") && n.includes("CC PAYMENT")) || (m.includes("ELECTRONIC WITHDRAWAL") && m.includes("CC PAYMENT"))) return true;

  // Credit card side
  if (n.includes("MOBILE PAYMENT THANK YOU") || m.includes("MOBILE PAYMENT THANK YOU")) return true;

  return false;
}

function heuristicCategory(txType, merchant, memo, amount) {
  const t = (txType || "").toUpperCase();
  const n = (merchant || "").toUpperCase();
  const m = (memo || "").toUpperCase();

  // Transfers (tight)
  if (isTransferByText(n, m)) return "Transfer";

  // Investing
  if (n.includes("FIDELITY") || n.includes("FID BKG") || m.includes("FIDELITY") || m.includes("FID BKG")) return "Investing";

  // ========= EXACT vendor matches (your requested strings) =========
  // Mortgage (either string)
  if (
    n.includes("WEB AUTHORIZED PMT JFG EXTERNALXFER") || m.includes("WEB AUTHORIZED PMT JFG EXTERNALXFER") ||
    n.includes("ELECTRONIC WITHDRAWAL JBM RECEIVABLE") || m.includes("ELECTRONIC WITHDRAWAL JBM RECEIVABLE")
  ) {
    return "Mortgage";
  }

  // Wife's car payment
  if (n.includes("ELECTRONIC WITHDRAWAL WPM") || m.includes("ELECTRONIC WITHDRAWAL WPM")) return "Car Payment";

  // HOA
  if (n.includes("WEB AUTHORIZED PMT PMI OF GREATER M") || m.includes("WEB AUTHORIZED PMT PMI OF GREATER M")) return "HOA";
  // ================================================================

  // Utilities
  if (n.includes("SPECTRUM") || m.includes("SPECTRUM")) return "Utilities";
  if (n.includes("WE ENERGIES") || m.includes("WE ENERGIES")) return "Utilities";

  // Phone (general)
  if (n.includes("US CELLULAR") || n.includes("U.S. CELLULAR") || n.includes("USCELLULAR") ||
      m.includes("US CELLULAR") || m.includes("U.S. CELLULAR") || m.includes("USCELLULAR")) return "Phone";
  if (n.includes("VERIZON") || m.includes("VERIZON")) return "Phone";

  // Gas
  if (n.includes("KWIK TRIP") || n.includes("EXXON") || n.includes("SHELL") ||
      m.includes("KWIK TRIP") || m.includes("EXXON") || m.includes("SHELL") || n.includes("BP#") || m.includes("BP#")) return "Gas";

  // Shopping/Groceries
  if (n.includes("AMAZON") || m.includes("AMAZON")) return "Shopping";
  if (n.includes("TARGET") || m.includes("TARGET")) return "Shopping";
  if (n.includes("WALMART") || m.includes("WALMART")) return "Shopping";
  if (n.includes("PICK N SAVE") || n.includes("KROGER") || m.includes("PICK N SAVE") || m.includes("KROGER")) return "Groceries";
  if (n.includes("COSTCO") || m.includes("COSTCO")) return "Groceries";

  // Subscriptions
  if (n.includes("DISNEY") || n.includes("APPLE") || n.includes("NETFLIX") || n.includes("HULU") || n.includes("SPOTIFY") || n.includes("CHATGPT")
      || m.includes("DISNEY") || m.includes("APPLE") || m.includes("NETFLIX") || m.includes("HULU") || m.includes("SPOTIFY") || m.includes("CHATGPT")) {
    return "Subscriptions";
  }

  // Income (for checking deposits etc.)
  if (t === "CREDIT" && (n.includes("PAYROLL") || m.includes("PAYROLL") || n.includes("DIRECT DEP") || m.includes("DIRECT DEP") || n.includes("DEPOSIT") || m.includes("DEPOSIT"))) {
    return "Income";
  }

  return amount < 0 ? "Other" : "Other";
}

function categorize(txType, name, memo, amount) {
  if (isMarkerRow(txType, name, memo)) return "Starting Balance";
  const merchant = normalizeMerchant(name, memo);
  const ruleCat = applyRulesCategory(merchant);
  if (ruleCat) return ruleCat;
  return heuristicCategory(txType, merchant, memo, amount);
}

function recategorizeAll() {
  allTransactions = allTransactions.map(t => {
    if (t.category === "Starting Balance") return t;
    const merchant = normalizeMerchant(t.name, t.memo);
    const cat = categorize(t.txType, t.name, t.memo, t.amount);
    return { ...t, merchant, category: cat };
  });
  saveAll();
}

/* =========================================================
   3) Import Pipeline (CSV → schema → dedupe) + AUTO RANGE
========================================================= */
function inferImportMode(fileName) {
  const n = String(fileName || "").toLowerCase();
  if (n.includes("credit card")) return "credit";
  if (n.includes("checking")) return "checking";
  return null;
}

/* ======== NEW helper: treat Transfer as reserved + trimmed ======== */
function isTransferCat(t) {
  // Primary: explicit category
  if ((t.category || "").trim() === "Transfer") return true;

  // Fallback: exclude known transfer/CC-payment rows even if they were categorized before the rules existed
  return isTransferByText(t.merchant || t.name || "", t.memo || "");
}
/* ================================================================= */

async function importCSVFile(file, importMode, cardLast4) {
  const text = await file.text();
  const rows = parseCSV(text);
  if (rows.length < 2) throw new Error("CSV looks empty.");

  const header = rows[0].map(h => (h || "").trim());
  const iDate = indexOfAny(header, ["Date", "Posting Date", "Transaction Date"]);
  const iTx   = indexOfAny(header, ["Transaction", "Type"]);
  const iName = indexOfAny(header, ["Name", "Merchant", "Description"]);
  const iMemo = indexOfAny(header, ["Memo", "Details", "Note"]);
  const iAmt  = indexOfAny(header, ["Amount", "Transaction Amount"]);

  if (iDate < 0 || iName < 0 || iAmt < 0) {
    throw new Error("Missing required columns. Need at least: Date + Name + Amount.");
  }

  // Determine account fields
  let accountType = importMode;
  let accountId = (accountType === "credit") ? `cc-${cardLast4 || "????"}` : "checking";
  let accountName = (accountType === "credit") ? `Credit Card ${cardLast4 || ""}` : "Checking";
  let accountLast4 = (accountType === "credit") ? String(cardLast4 || "") : "";

  if (accountType === "credit") {
    if (!accountLast4) {
      throw new Error("Credit card import needs a selected card (last 4).");
    }
    const profile = getOrCreateCardProfile(accountLast4, accountName);
    accountName = profile.name || accountName;
    accountId = profile.id || accountId;
  }

  let added = 0, skipped = 0, failed = 0;
  const debugRows = [];
  let minISO = null, maxISO = null;

  for (const r of rows.slice(1)) {
    try {
      const dateStr = (r[iDate] ?? "").trim();
      const txType  = (iTx >= 0 ? (r[iTx] ?? "").trim() : "");
      const name    = (r[iName] ?? "").trim();
      const memo    = (iMemo >= 0 ? (r[iMemo] ?? "").trim() : "");
      const amount  = parseMoney(r[iAmt]);

      const d = parseDateSmart(dateStr);
      if (!d || amount === null) { failed++; continue; }

      const dateISO = d.toISOString().slice(0, 10);
      const month = yyyymmFromDate(d);

      minISO = (!minISO || dateISO < minISO) ? dateISO : minISO;
      maxISO = (!maxISO || dateISO > maxISO) ? dateISO : maxISO;

      const merchant = normalizeMerchant(name, memo);
      const category = categorize(txType, name, memo, amount);

      // Dedupe should be account-aware
      const key = `${accountId}|${dateISO}|${(txType||"").toUpperCase()}|${name}|${memo}|${amount.toFixed(2)}`;
      if (allTransactions.some(t => t.key === key)) { skipped++; continue; }

      const record = {
        key,
        dateISO,
        month,
        txType,
        name,
        memo,
        merchant,
        amount,
        category,
        accountType,
        accountId,
        accountName,
        accountLast4
      };

      allTransactions.push(record);
      added++;
      if (debugRows.length < 6) debugRows.push(record);
    } catch {
      failed++;
    }
  }

  importMeta.push({
    fileName: file.name,
    importedAtISO: new Date().toISOString(),
    added, skipped, failed,
    mode: accountType,
    cardLast4: accountLast4 || null,
    range: { minISO, maxISO }
  });

  saveAll();
  return { added, skipped, failed, debugRows, range: { minISO, maxISO }, mode: accountType, cardLast4: accountLast4 || null };
}

/* =========================================================
   4) Range / Scope selection
========================================================= */
function getDataRange() {
  return { minISO: minDateISO(allTransactions) || "", maxISO: maxDateISO(allTransactions) || "" };
}

function getScope() {
  const mode = els.viewMode.value;

  if (mode === "all") {
    const { minISO, maxISO } = getDataRange();
    return { mode, startISO: minISO, endISO: maxISO, label: `All time (${minISO} → ${maxISO})` };
  }

  if (mode === "month") {
    const month = els.monthSelect.value || yyyymmFromDate(new Date());
    const startISO = `${month}-01`;
    const [y,m] = month.split("-").map(n=>parseInt(n,10));
    const last = new Date(y, m, 0).toISOString().slice(0,10);
    return { mode, startISO, endISO:last, label: `Month ${month}` };
  }

  const { minISO, maxISO } = getDataRange();
  const startISO = els.rangeStart.value || minISO;
  const endISO = els.rangeEnd.value || maxISO;
  return { mode:"range", startISO, endISO, label: `Range ${startISO} → ${endISO}` };
}

function filterToScope(tx, scope) {
  const s = scope.startISO || "0000-01-01";
  const e = scope.endISO || "9999-12-31";
  return tx.filter(t => t.dateISO >= s && t.dateISO <= e);
}

/* =========================================================
   5) Totals + Running balance
========================================================= */
function scopeTotals(scopeTxAll) {
  const scopeTx = scopeTxAll.filter(t => t.category !== "Starting Balance");

  // FIX: Exclude transfers from Income
  const income = scopeTx
    .filter(t => t.amount > 0)
    .filter(t => !isTransferCat(t))
    .reduce((s,t)=>s+t.amount,0);

  // FIX: Exclude transfers from Outflows
  const outflows = scopeTx
    .filter(t => t.amount < 0)
    .filter(t => !isTransferCat(t))
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const transferOut = scopeTx
    .filter(t => isTransferCat(t) && t.amount < 0)
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const transferIn  = scopeTx
    .filter(t => isTransferCat(t) && t.amount > 0)
    .reduce((s,t)=>s+t.amount,0);

  const transfers = transferIn - transferOut;

  const spending = scopeTx
    .filter(t => t.amount < 0)
    .filter(t => !isTransferCat(t))
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const netChange = scopeTx.reduce((s,t)=>s + Number(t.amount || 0), 0);

  return { income, outflows, transfers, spending, netChange, scopeTxAll, scopeTx };
}

function computeRunningBalanceAt(endISO) {
  if (!endISO) return { runningBal: null, explain: "No end date.", anchor: null, deltaFromAnchor: null };

  const markers = allTransactions
    .filter(t => t.category === "Starting Balance")
    .slice()
    .sort((a,b) => a.dateISO > b.dateISO ? 1 : -1);

  const candidates = markers.filter(m => m.dateISO <= endISO);
  const anchor = candidates.length ? candidates[candidates.length - 1] : null;

  if (!anchor) return { runningBal: null, explain: `No starting balance marker found on/before ${endISO}.`, anchor: null, deltaFromAnchor: null };

  const scope = allTransactions
    .filter(t => t.category !== "Starting Balance")
    .filter(t => t.dateISO >= anchor.dateISO && t.dateISO <= endISO);

  const netSinceAnchor = scope.reduce((s,t)=>s + Number(t.amount || 0), 0);
  return {
    runningBal: anchor.amount + netSinceAnchor,
    deltaFromAnchor: netSinceAnchor,
    anchor,
    explain: `Anchor ${money(anchor.amount)} on ${anchor.dateISO} → as of ${endISO}`
  };
}

function computeCheckingBalanceAt(endISO) {
  if (!endISO) return { runningBal: null, explain: "No end date.", anchor: null, deltaFromAnchor: null, deposits: 0, withdrawals: 0, txCount: 0 };

  const markers = allTransactions
    .filter(t => t.accountId === "checking")
    .filter(t => t.category === "Starting Balance")
    .slice()
    .sort((a,b) => a.dateISO > b.dateISO ? 1 : -1);

  const candidates = markers.filter(m => m.dateISO <= endISO);
  const anchor = candidates.length ? candidates[candidates.length - 1] : null;

  if (!anchor) return { runningBal: null, explain: `No checking starting balance marker found on/before ${endISO}.`, anchor: null, deltaFromAnchor: null, deposits: 0, withdrawals: 0, txCount: 0 };

  const scope = allTransactions
    .filter(t => t.accountId === "checking")
    .filter(t => t.category !== "Starting Balance")
    .filter(t => t.dateISO >= anchor.dateISO && t.dateISO <= endISO)
    .map(t => ({ ...t, amount: (Number.isFinite(t.amount) ? t.amount : 0) }));

  let deposits = 0;
  let withdrawals = 0;
  for (const t of scope) {
    if (t.amount >= 0) deposits += t.amount;
    else withdrawals += t.amount;
  }
  const netSinceAnchor = deposits + withdrawals;
  const runningBal = anchor.amount + netSinceAnchor;

  const explain = `Anchor ${money(anchor.amount)} on ${anchor.dateISO} → as of ${endISO} · ${scope.length} tx · Deposits ${money(deposits)} · Withdrawals ${money(withdrawals)} · Net ${moneySigned(netSinceAnchor)}`;

  return { runningBal, deltaFromAnchor: netSinceAnchor, anchor, explain, deposits, withdrawals, txCount: scope.length };
}

/* =========================================================
   6) Smart Insights
========================================================= */
function groupBy(arr, keyFn) {
  const m = new Map();
  for (const x of arr) {
    const k = keyFn(x);
    if (!m.has(k)) m.set(k, []);
    m.get(k).push(x);
  }
  return m;
}

function median(nums) {
  const a = nums.slice().sort((x,y)=>x-y);
  if (!a.length) return 0;
  const mid = Math.floor(a.length / 2);
  return a.length % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
}

function detectRecurring(transactions) {
  const tx = transactions
    .filter(t => t.category !== "Starting Balance")
    .filter(t => t.amount < 0)
    .filter(t => !isTransferCat(t));

  const byMerchant = groupBy(tx, t => (t.merchant || t.name || "").toLowerCase().trim());
  const results = [];

  for (const [merchantKey, items] of byMerchant.entries()) {
    if (!merchantKey) continue;
    if (items.length < 3) continue;

    const months = new Set(items.map(i => i.month));
    if (months.size < 2) continue;

    const amts = items.map(i => Math.abs(i.amount));
    const med = median(amts);
    if (med <= 0) continue;

    const within = amts.filter(a => Math.abs(a - med) / med <= 0.15).length;
    const stability = within / amts.length;

    const doms = items.map(i => parseInt(i.dateISO.slice(8,10), 10));
    const domMed = median(doms);
    const domWithin = doms.filter(d => Math.abs(d - domMed) <= 3).length / doms.length;

    const score = 0.55 * stability + 0.45 * domWithin;
    if (score < 0.6) continue;

    const name = items[0].merchant || items[0].name || "Unknown";
    const likely = (med < 40) ? "Subscription" : "Bill";
    results.push({ name, likely, typicalAmount: med, monthsCount: months.size, occurrences: items.length, score });
  }

  results.sort((a,b)=>b.score - a.score);
  return results.slice(0, 12);
}

function detectPaychecks(transactions) {
  const credits = transactions
    .filter(t => t.category !== "Starting Balance")
    .filter(t => t.amount > 0)
    .filter(t => !isTransferCat(t));

  if (credits.length < 3) return { summary: "No paycheck pattern yet", paychecks: [], spikes: [] };

  const payrollish = credits.filter(t => {
    const n = (t.name || "").toUpperCase();
    const m = (t.memo || "").toUpperCase();
    const cat = (t.category || "");
    if (cat === "Income") return true;
    if (n.includes("PAYROLL") || m.includes("PAYROLL") || n.includes("DIRECT DEP") || m.includes("DIRECT DEP")) return true;
    return t.amount >= 500;
  });

  if (payrollish.length < 3) return { summary: "No paycheck pattern yet", paychecks: [], spikes: [] };

  const sorted = payrollish.slice().sort((a,b)=>a.dateISO > b.dateISO ? 1 : -1);

  const intervals = [];
  for (let i=1; i<sorted.length; i++) intervals.push(daysBetweenISO(sorted[i-1].dateISO, sorted[i].dateISO));
  const intervalMed = median(intervals);
  const biweekly = intervalMed >= 13 && intervalMed <= 15;

  const amounts = sorted.map(t => t.amount);
  const base = median(amounts);

  const spikes = sorted
    .filter(t => t.amount > base * 1.10)
    .map(t => ({ dateISO: t.dateISO, amount: t.amount, delta: t.amount - base }))
    .slice(-6);

  const summary =
    biweekly
      ? `Biweekly pattern detected • baseline ${money(base)}`
      : `Paycheck-like credits detected • baseline ${money(base)} (interval median: ~${Math.round(intervalMed)} days)`;

  return { summary, paychecks: sorted.slice(-8), spikes };
}

/* =========================================================
   7) Reconciliation
========================================================= */
function buildReconciliation() {
  if (!allTransactions.length) return { line: "No imports yet", details: "" };

  const minISO = minDateISO(allTransactions);
  const maxISO = maxDateISO(allTransactions);

  const dates = new Set(allTransactions.map(t => t.dateISO));
  const gaps = [];
  let cursor = minISO;
  let inGap = null;

  while (cursor <= maxISO) {
    const has = dates.has(cursor);
    if (!has && !inGap) inGap = { start: cursor, end: cursor };
    if (!has && inGap) inGap.end = cursor;
    if (has && inGap) { gaps.push(inGap); inGap = null; }
    cursor = isoAddDays(cursor, 1);
  }
  if (inGap) gaps.push(inGap);

  const bigGaps = gaps.filter(g => daysBetweenISO(g.start, g.end) + 1 >= 4).slice(0, 8);
  const lastImport = importMeta.length ? importMeta[importMeta.length - 1] : null;

  const line = lastImport
    ? `Last import: +${lastImport.added} (skipped ${lastImport.skipped}, failed ${lastImport.failed}) • Data range ${minISO} → ${maxISO}`
    : `Data range ${minISO} → ${maxISO}`;

  const details = bigGaps.length
    ? `Potential missing date gaps (≥4 days): ` + bigGaps.map(g => `${g.start}→${g.end}`).join(" • ")
    : `No large missing-date gaps detected (weekends ignored by threshold).`;

  return { line, details };
}

/* =========================================================
   8) Charts (legend INSIDE canvas)
========================================================= */
function hashToHue(str) { let h=0; for (let i=0;i<str.length;i++) h=(h*31+str.charCodeAt(i))>>>0; return h%360; }
function colorForLabel(label){ return `hsl(${hashToHue(String(label||""))} 70% 55%)`; }

function drawPieWithLegend(canvas, data, title, legendMax=10) {
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = "#0f1726";
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = "#e8eefc";
  ctx.font = "900 18px -apple-system,BlinkMacSystemFont,system-ui,sans-serif";
  ctx.fillText(title, 18, 28);

  const total = data.reduce((s, d) => s + d.value, 0);
  if (!total) {
    ctx.fillStyle = "#9fb0d0";
    ctx.font = "600 14px -apple-system,BlinkMacSystemFont,system-ui,sans-serif";
    ctx.fillText("No data for this scope.", 18, 60);
    return;
  }

  const cx = Math.round(W * 0.30);
  const cy = Math.round(H * 0.58);
  const r = Math.round(Math.min(W, H) * 0.30);

  let start = -Math.PI / 2;
  for (const d of data) {
    const frac = d.value / total;
    const end = start + frac * Math.PI * 2;
    ctx.fillStyle = colorForLabel(d.label);
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, r, start, end);
    ctx.closePath();
    ctx.fill();
    start = end;
  }

  ctx.fillStyle = "#0f1726";
  ctx.beginPath();
  ctx.arc(cx, cy, Math.round(r * 0.55), 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#e8eefc";
  ctx.font = "900 16px -apple-system,BlinkMacSystemFont,system-ui,sans-serif";
  ctx.fillText(money(total), cx - 55, cy + 6);

  const legend = data.slice().sort((a,b)=>b.value-a.value).slice(0, legendMax);
  const lx = Math.round(W * 0.62);
  const ly0 = 58;
  const rowH = 22;
  const sw = 12, sh = 12;

  ctx.font = "800 12px -apple-system,BlinkMacSystemFont,system-ui,sans-serif";
  ctx.textBaseline = "middle";

  ctx.fillStyle = "rgba(255,255,255,0.06)";
  ctx.fillRect(lx, 42, W - lx - 18, 1);

  for (let i=0;i<legend.length;i++) {
    const item = legend[i];
    const y = ly0 + i * rowH;

    ctx.fillStyle = colorForLabel(item.label);
    ctx.fillRect(lx, y - sh/2, sw, sh);

    ctx.fillStyle = "#e8eefc";
    ctx.fillText(String(item.label), lx + sw + 10, y);

    const valueText = money(item.value);
    ctx.fillStyle = "#9fb0d0";
    const rightX = W - 18;
    const metrics = ctx.measureText(valueText);
    ctx.fillText(valueText, rightX - metrics.width, y);
  }

  if (data.length > legendMax) {
    const y = ly0 + legendMax * rowH;
    ctx.fillStyle = "#9fb0d0";
    ctx.fillText(`+${data.length - legendMax} more`, lx + sw + 10, y);
  }

  ctx.textBaseline = "alphabetic";
}

/* =========================================================
   9) Credit Card Dashboard helpers
========================================================= */
function computeCardScopeStats(scopeTx) {
  const cards = cardProfiles.slice().sort((a,b)=>String(a.last4).localeCompare(String(b.last4)));
  const stats = [];

  for (const c of cards) {
    const tx = scopeTx
      .filter(t => t.category !== "Starting Balance")
      .filter(t => t.accountType === "credit")
      .filter(t => String(t.accountLast4 || "") === String(c.last4 || ""));

    const spend = tx
      .filter(t => t.amount < 0)
      .filter(t => !isTransferCat(t))
      .reduce((s,t)=>s+Math.abs(t.amount),0);

    const payments = tx
      .filter(t => t.amount > 0)
      .filter(t => isTransferCat(t)) // mobile payment thank you
      .reduce((s,t)=>s+t.amount,0);

    const net = tx.reduce((s,t)=>s+Number(t.amount||0),0);

    const bal = (c.balance === null || c.balance === undefined || c.balance === "") ? null : Number(c.balance);
    const limit = (c.limit === null || c.limit === undefined || c.limit === "") ? null : Number(c.limit);
    const util = (bal !== null && limit) ? (bal / limit) : null;

    stats.push({ card:c, spend, payments, net, balance:bal, limit, util });
  }
  return stats;
}

function payoffPlannerSummary() {
  const cards = cardProfiles
    .map(c => ({
      ...c,
      balance: (c.balance === null || c.balance === "" || c.balance === undefined) ? null : Number(c.balance),
      apr: (c.apr === null || c.apr === "" || c.apr === undefined) ? null : Number(c.apr),
      minPayment: (c.minPayment === null || c.minPayment === "" || c.minPayment === undefined) ? null : Number(c.minPayment)
    }))
    .filter(c => c.balance !== null && c.balance > 0);

  if (!cards.length) {
    return { headline: "Add balances to enable payoff guidance", details: "Open Card Settings and enter each card’s current balance (and APR/min payment if you want smart ordering)." };
  }

  const totalBal = cards.reduce((s,c)=>s+c.balance,0);
  const totalMin = cards.reduce((s,c)=>s+(c.minPayment || 0),0);

  const hasAPR = cards.some(c => c.apr !== null);
  const hasMin = cards.some(c => c.minPayment !== null);

  let avalanche = cards.slice().sort((a,b) => (b.apr||0) - (a.apr||0));
  let snowball  = cards.slice().sort((a,b) => (a.balance||0) - (b.balance||0));

  const aLine = hasAPR
    ? `Avalanche order (highest APR first): ` + avalanche.map(c => `${c.name || ("Card "+c.last4)} (${c.apr||"?"}% • ${money(c.balance)})`).join(" • ")
    : `Avalanche order needs APRs. Enter APR for better guidance.`;

  const sLine = `Snowball order (smallest balance first): ` + snowball.map(c => `${c.name || ("Card "+c.last4)} (${money(c.balance)})`).join(" • ");

  const note = hasMin
    ? `Total minimum payments: ${money(totalMin)}`
    : `Enter minimum payments to see “total mins” and better payoff planning.`;

  return {
    headline: `Total CC balance: ${money(totalBal)}`,
    details: `${note}<br><br>${escapeHtml(aLine)}<br><br>${escapeHtml(sLine)}`
  };
}

/* =========================================================
   10) UI Wiring + Dashboard
========================================================= */
const els = {
  viewMode: document.getElementById("viewMode"),
  rangeWrap: document.getElementById("rangeWrap"),
  monthWrap: document.getElementById("monthWrap"),
  rangeStart: document.getElementById("rangeStart"),
  rangeEnd: document.getElementById("rangeEnd"),
  rangeToAllDataBtn: document.getElementById("rangeToAllDataBtn"),
  rangeLast90Btn: document.getElementById("rangeLast90Btn"),
  rangeThisMonthBtn: document.getElementById("rangeThisMonthBtn"),
  monthSelect: document.getElementById("monthSelect"),
  chartMode: document.getElementById("chartMode"),
  pieCanvas: document.getElementById("pieCanvas"),
  pieSummary: document.getElementById("pieSummary"),

  scopePill: document.getElementById("scopePill"),
  topLine: document.getElementById("topLine"),
  topSub: document.getElementById("topSub"),
  balanceSub: document.getElementById("balanceSub"),

  income: document.getElementById("income"),
  outflows: document.getElementById("outflows"),
  spending: document.getElementById("spending"),
  transfers: document.getElementById("transfers"),
  netChange: document.getElementById("netChange"),
  balanceBox: document.getElementById("balanceBox"),
  balanceHint: document.getElementById("balanceHint"),

  checkingBalanceBox: document.getElementById("checkingBalanceBox"),
  checkingBalanceHint: document.getElementById("checkingBalanceHint"),

  ccKpiLine: document.getElementById("ccKpiLine"),
  ccTableWrap: document.getElementById("ccTableWrap"),
  payoffHeadline: document.getElementById("payoffHeadline"),
  payoffDetails: document.getElementById("payoffDetails"),

  cardSettingsWrap: document.getElementById("cardSettingsWrap"),
  addCardBtn: document.getElementById("addCardBtn"),
  saveCardSettingsBtn: document.getElementById("saveCardSettingsBtn"),
  selectAllCardsBtn: document.getElementById("selectAllCardsBtn"),
  trashCardsAlsoTxChk: document.getElementById("trashCardsAlsoTxChk"),
  trashSelectedCardsBtn: document.getElementById("trashSelectedCardsBtn"),
  cardsTrashCount: document.getElementById("cardsTrashCount"),
  cardsTrashWrap: document.getElementById("cardsTrashWrap"),
  clearCardsTrashBtn: document.getElementById("clearCardsTrashBtn"),
  cardSettingsStatus: document.getElementById("cardSettingsStatus"),

  recurringCount: document.getElementById("recurringCount"),
  recurringList: document.getElementById("recurringList"),
  paycheckSummary: document.getElementById("paycheckSummary"),
  paycheckList: document.getElementById("paycheckList"),
  reconLine: document.getElementById("reconLine"),
  reconDetails: document.getElementById("reconDetails"),

  fileInput: document.getElementById("fileInput"),
  importBtn: document.getElementById("importBtn"),
  removeMarkersBtn: document.getElementById("removeMarkersBtn"),
  clearBtn: document.getElementById("clearBtn"),
  status: document.getElementById("status"),
  debug: document.getElementById("debug"),

  importAs: document.getElementById("importAs"),
  importCardWrap: document.getElementById("importCardWrap"),
  importCard: document.getElementById("importCard"),

  countPill: document.getElementById("countPill"),
  tableBody: document.getElementById("tableBody"),

  ruleContains: document.getElementById("ruleContains"),
  ruleCategory: document.getElementById("ruleCategory"),
  addRuleBtn: document.getElementById("addRuleBtn"),
  reapplyRulesBtn: document.getElementById("reapplyRulesBtn"),
  selectAllRulesBtn: document.getElementById("selectAllRulesBtn"),
  trashSelectedRulesBtn: document.getElementById("trashSelectedRulesBtn"),
  clearRulesBtn: document.getElementById("clearRulesBtn"),
  rulesTableWrap: document.getElementById("rulesTableWrap"),
  rulesTrashCount: document.getElementById("rulesTrashCount"),
  rulesTrashWrap: document.getElementById("rulesTrashWrap"),
  clearRulesTrashBtn: document.getElementById("clearRulesTrashBtn")
};

function updateViewModeUI() {
  const mode = els.viewMode.value;
  els.rangeWrap.style.display = (mode === "range") ? "" : "none";
  els.monthWrap.style.display = (mode === "month") ? "" : "none";
}

function buildCategoryBreakdown(scopeTx) {
  const spend = scopeTx.filter(t => t.amount < 0).filter(t => !isTransferCat(t));
  const byCat = new Map();
  for (const t of spend) {
    const cat = (t.category || "Other").trim() || "Other";
    byCat.set(cat, (byCat.get(cat) || 0) + Math.abs(t.amount));
  }
  const data = Array.from(byCat.entries()).map(([label, value]) => ({ label, value }));
  data.sort((a,b)=>b.value - a.value);
  return data;
}

function updateRulesTable() {
  const anySelected = () => !!els.rulesTableWrap.querySelector("input[data-rulechk]:checked");

  if (!userRules.length) {
    els.rulesTableWrap.innerHTML = `<p class="small">No rules yet.</p>`;
    els.trashSelectedRulesBtn.disabled = true;
    return;
  }

  const rows = userRules.map((r, idx) => `
    <tr>
      <td style="width:40px; text-align:center;">
        <input type="checkbox" data-rulechk="${idx}" />
      </td>
      <td class="mono">${idx + 1}</td>
      <td class="mono">${escapeHtml(r.contains || "")}</td>
      <td>${escapeHtml(r.category || "")}</td>
      <td><button class="ghost" data-trash="${idx}">Trash</button></td>
      <td><button class="ghost" data-up="${idx}">Up</button></td>
      <td><button class="ghost" data-down="${idx}">Down</button></td>
    </tr>
  `).join("");

  els.rulesTableWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead><tr><th></th><th>#</th><th>Contains</th><th>Category</th><th></th><th></th><th></th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;

  const refreshBulkState = () => {
    els.trashSelectedRulesBtn.disabled = !anySelected();
  };

  els.rulesTableWrap.querySelectorAll('input[data-rulechk]').forEach(chk => {
    chk.addEventListener("change", refreshBulkState);
  });

  els.rulesTableWrap.querySelectorAll("button[data-trash]").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-trash"));
      moveRulesToTrash([i]);
    });
  });

  els.rulesTableWrap.querySelectorAll("button[data-up]").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-up"));
      if (i <= 0) return;
      const tmp = userRules[i-1];
      userRules[i-1] = userRules[i];
      userRules[i] = tmp;
      saveAll();
      updateRulesTable();
      recategorizeAll();
      updateDashboard();
    });
  });

  els.rulesTableWrap.querySelectorAll("button[data-down]").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-down"));
      if (i >= userRules.length - 1) return;
      const tmp = userRules[i+1];
      userRules[i+1] = userRules[i];
      userRules[i] = tmp;
      saveAll();
      updateRulesTable();
      recategorizeAll();
      updateDashboard();
    });
  });

  refreshBulkState();
}

function renderRulesTrash() {
  const items = (trashStore.rules || []).slice().sort((a,b) => (a.deletedAt || "").localeCompare(b.deletedAt || "")).reverse();
  els.rulesTrashCount.textContent = String(items.length);
  els.clearRulesTrashBtn.disabled = items.length === 0;

  if (!items.length) {
    els.rulesTrashWrap.innerHTML = `<div class="small">Trash is empty.</div>`;
    return;
  }

  const rows = items.map((entry) => {
    const ts = entry.deletedAt ? formatDateTime(entry.deletedAt) : "";
    const r = entry.rule || {};
    return `
      <tr>
        <td class="mono">${ts}</td>
        <td class="mono">${escapeHtml(r.contains || "")}</td>
        <td>${escapeHtml(r.category || "")}</td>
        <td><button class="ghost" data-restore-rule="${entry.trashId}">Restore</button></td>
        <td><button class="danger" data-del-rule="${entry.trashId}">Delete Permanently</button></td>
      </tr>
    `;
  }).join("");

  els.rulesTrashWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead><tr><th>Deleted</th><th>Contains</th><th>Category</th><th></th><th></th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;

  els.rulesTrashWrap.querySelectorAll('button[data-restore-rule]').forEach(btn => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-restore-rule");
      restoreRuleFromTrash(id);
    });
  });

  els.rulesTrashWrap.querySelectorAll('button[data-del-rule]').forEach(btn => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-del-rule");
      if (!confirm("Permanently delete this rule from Trash? This can't be undone.")) return;
      trashStore.rules = (trashStore.rules || []).filter(x => x.trashId !== id);
      saveAll();
      renderRulesTrash();
    });
  });
}

/* ===================== Top headline is Monthly Performance ======================= */
function updateTopDelta(scope, totals) {
  const monthlyPerformance = Number(totals.income || 0) - Number(totals.spending || 0);

  els.topLine.textContent = moneySigned(monthlyPerformance);
  els.topLine.classList.remove("pos","neg");
  if (monthlyPerformance > 0) els.topLine.classList.add("pos");
  else if (monthlyPerformance < 0) els.topLine.classList.add("neg");

  els.topSub.textContent = `Monthly Performance (Income − Spending, transfers excluded) • ${scope.label}`;
}
/* =============================================================================== */

function renderCardSettings() {
  if (!cardProfiles.length) {
    els.cardSettingsWrap.innerHTML = `<div class="small hint">No cards yet. Click “Add Card Profile”.</div>`;
    els.trashSelectedCardsBtn.disabled = true;
    return;
  }

  const rows = cardProfiles.map((c, idx) => {
    return `
      <div class="kpiBox" style="margin-bottom:10px;">
        <div class="row" style="align-items:flex-start;">
          <div style="min-width:44px; padding-top:6px; text-align:center;">
            <input type="checkbox" data-cardchk="${idx}" />
          </div>

          <div style="min-width:260px;">
            <div class="t">Card Name</div>
            <input data-card="${idx}" data-field="name" value="${escapeHtml(c.name||"")}" />
            <div class="hint">Last4: <span class="mono">${escapeHtml(c.last4||"")}</span></div>
          </div>

          <div style="min-width:160px;">
            <div class="t">Limit</div>
            <input data-card="${idx}" data-field="limit" placeholder="e.g. 8000" value="${c.limit ?? ""}" />
          </div>

          <div style="min-width:160px;">
            <div class="t">Balance (current)</div>
            <input data-card="${idx}" data-field="balance" placeholder="e.g. 2450" value="${c.balance ?? ""}" />
          </div>

          <div style="min-width:160px;">
            <div class="t">APR %</div>
            <input data-card="${idx}" data-field="apr" placeholder="e.g. 23.99" value="${c.apr ?? ""}" />
          </div>

          <div style="min-width:160px;">
            <div class="t">Min Payment</div>
            <input data-card="${idx}" data-field="minPayment" placeholder="e.g. 75" value="${c.minPayment ?? ""}" />
          </div>

          <div style="min-width:160px;">
            <div class="t">Due Day (1-31)</div>
            <input data-card="${idx}" data-field="dueDay" placeholder="e.g. 15" value="${c.dueDay ?? ""}" />
          </div>
        </div>

        <div class="small hint" style="margin-top:8px;">
          Tip: use “Move Selected to Trash” to remove one or more cards safely. You can restore them from Trash later.
        </div>
      </div>
    `;
  }).join("");

  els.cardSettingsWrap.innerHTML = rows;

  const refreshBulk = () => {
    const any = !!els.cardSettingsWrap.querySelector('input[data-cardchk]:checked');
    els.trashSelectedCardsBtn.disabled = !any;
  };

  els.cardSettingsWrap.querySelectorAll('input[data-cardchk]').forEach(chk => {
    chk.addEventListener("change", refreshBulk);
  });

  refreshBulk();
}

function readCardSettingsFromUI() {
  const inputs = els.cardSettingsWrap.querySelectorAll("input[data-card][data-field]");
  inputs.forEach(inp => {
    const idx = Number(inp.getAttribute("data-card"));
    const field = inp.getAttribute("data-field");
    if (!cardProfiles[idx]) return;
    cardProfiles[idx][field] = inp.value;
  });
}

function populateImportCardDropdown(selectLast4=null) {
  els.importCard.innerHTML = "";
  const sorted = cardProfiles.slice().sort((a,b)=>String(a.last4).localeCompare(String(b.last4)));
  for (const c of sorted) {
    const opt = document.createElement("option");
    opt.value = c.last4;
    opt.textContent = `${c.name || ("Card "+c.last4)} (${c.last4})`;
    els.importCard.appendChild(opt);
  }
  if (selectLast4) els.importCard.value = String(selectLast4);
}

function renderCardsTrash() {
  ensureTrashStoreShape();
  const items = (trashStore.cards || []).slice().sort((a,b) => (a.deletedAt || "").localeCompare(b.deletedAt || "")).reverse();
  els.cardsTrashCount.textContent = String(items.length);
  els.clearCardsTrashBtn.disabled = items.length === 0;

  if (!items.length) {
    els.cardsTrashWrap.innerHTML = `<div class="small">Trash is empty.</div>`;
    return;
  }

  const rows = items.map(entry => {
    const ts = entry.deletedAt ? formatDateTime(entry.deletedAt) : "";
    const c = entry.card || {};
    const txNote = entry.txTrashId ? `<span class="tag">Tx included</span>` : `<span class="tag">Profile only</span>`;
    return `
      <tr>
        <td class="mono">${ts}</td>
        <td>${escapeHtml(c.name || "")} <span class="pill">•••• ${escapeHtml(c.last4 || "")}</span> ${txNote}</td>
        <td><button class="ghost" data-restore-card="${entry.trashId}">Restore</button></td>
        <td><button class="danger" data-del-card="${entry.trashId}">Delete Permanently</button></td>
      </tr>
    `;
  }).join("");

  els.cardsTrashWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead><tr><th>Deleted</th><th>Card</th><th></th><th></th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;

  els.cardsTrashWrap.querySelectorAll('button[data-restore-card]').forEach(btn => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-restore-card");
      restoreCardFromTrash(id);
    });
  });

  els.cardsTrashWrap.querySelectorAll('button[data-del-card]').forEach(btn => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-del-card");
      if (!confirm("Permanently delete this card from Trash? This can't be undone.")) return;

      const entry = (trashStore.cards || []).find(x => x.trashId === id);
      if (entry?.txTrashId) {
        trashStore.cardTx = (trashStore.cardTx || []).filter(x => x.trashId !== entry.txTrashId);
      }

      trashStore.cards = (trashStore.cards || []).filter(x => x.trashId !== id);
      saveAll();
      renderCardsTrash();
    });
  });
}

function updateImportUI() {
  const mode = els.importAs.value;
  els.importCardWrap.style.display = (mode === "credit") ? "" : "none";
}

function buildCashflowBreakdown(scopeTx) {
  const tx = scopeTx.filter(t => t.category !== "Starting Balance");
  const inflow = tx.filter(t => t.amount > 0).filter(t => !isTransferCat(t)).reduce((s,t)=>s+t.amount,0);
  const outflow = tx.filter(t => t.amount < 0).filter(t => !isTransferCat(t)).reduce((s,t)=>s+Math.abs(t.amount),0);
  return [
    { label: "Inflows", value: inflow },
    { label: "Outflows", value: outflow }
  ];
}

function updateDashboard() {
  ensureDefaultCards();
  ensureTrashStoreShape();

  updateViewModeUI();
  const scope = getScope();

  const { minISO, maxISO } = getDataRange();
  if (els.viewMode.value === "range") {
    if (!els.rangeStart.value && minISO) els.rangeStart.value = minISO;
    if (!els.rangeEnd.value && maxISO) els.rangeEnd.value = maxISO;
  }

  const scopedAll = filterToScope(allTransactions, scope);
  const totals = scopeTotals(scopedAll);

  updateTopDelta(scope, totals);

  els.scopePill.textContent = scope.label;

  els.income.textContent = money(totals.income);
  els.outflows.textContent = money(totals.outflows);
  els.spending.textContent = money(totals.spending);
  els.transfers.textContent = moneySigned(totals.transfers);
  els.netChange.textContent = moneySigned(totals.netChange);

  const rb = computeRunningBalanceAt(scope.endISO);
  els.balanceBox.textContent = (rb.runningBal === null) ? "—" : money(rb.runningBal);
  els.balanceHint.textContent = rb.explain || "";

  const cb = computeCheckingBalanceAt(scope.endISO);
  els.checkingBalanceBox.textContent = (cb.runningBal === null) ? "—" : money(cb.runningBal);
  els.checkingBalanceHint.textContent = cb.explain || "";

  if (rb.anchor) {
    els.balanceSub.innerHTML = `Running Balance anchor: <span class="mono">${rb.anchor.dateISO}</span> (${money(rb.anchor.amount)})`;
  } else {
    els.balanceSub.textContent = "";
  }

  const chartMode = els.chartMode.value;
  let chartData = [];
  let chartTitle = "";

  if (chartMode === "cashflow") {
    chartData = buildCashflowBreakdown(totals.scopeTxAll);
    chartTitle = "Cashflow (Transfers Excluded)";
  } else {
    chartData = buildCategoryBreakdown(totals.scopeTxAll);
    chartTitle = "Spending by Category";
  }

  drawPieWithLegend(els.pieCanvas, chartData, chartTitle, 10);

  if (chartMode === "cashflow") {
    const inflow = chartData.find(d => d.label === "Inflows")?.value || 0;
    const outflow = chartData.find(d => d.label === "Outflows")?.value || 0;
    els.pieSummary.innerHTML = `Inflows: <b>${money(inflow)}</b> • Outflows: <b>${money(outflow)}</b> (transfers excluded)`;
  } else {
    const totalSpend = chartData.reduce((s,d)=>s+d.value,0);
    const top3 = chartData.slice(0,3).map(d => `${escapeHtml(d.label)} ${money(d.value)}`).join(" • ");
    els.pieSummary.innerHTML = `Total spending: <b>${money(totalSpend)}</b> • Top: ${top3 || "—"}`;
  }

  const rows = totals.scopeTxAll
    .slice()
    .sort((a,b) => a.dateISO > b.dateISO ? -1 : 1)
    .slice(0, 400);

  els.countPill.textContent = `${totals.scopeTxAll.length} rows`;

  els.tableBody.innerHTML = rows.map(t => {
    const amtClass = t.amount >= 0 ? "pos" : "neg";
    return `
      <tr>
        <td class="mono">${escapeHtml(t.dateISO)}</td>
        <td>${escapeHtml(accountLabel(t))}</td>
        <td>${escapeHtml(t.txType || "")}</td>
        <td>${escapeHtml(t.name || "")}</td>
        <td>${escapeHtml(t.memo || "")}</td>
        <td>${escapeHtml(t.category || "")}</td>
        <td class="mono right ${amtClass}">${moneySigned(t.amount)}</td>
      </tr>
    `;
  }).join("");

  const recurring = detectRecurring(totals.scopeTxAll);
  els.recurringCount.textContent = String(recurring.length);
  els.recurringList.innerHTML = recurring.length
    ? recurring.map(r => `<div class="chip">${escapeHtml(r.name)} <span class="tag">${escapeHtml(r.likely)}</span> <span class="mono">${money(r.typicalAmount)}</span></div>`).join("")
    : `<div class="small hint">No recurring patterns detected yet.</div>`;

  const pay = detectPaychecks(totals.scopeTxAll);
  els.paycheckSummary.textContent = pay.summary || "—";
  const payLines = [];
  if (pay.paychecks?.length) {
    payLines.push(`<div class="small">Recent paycheck-like credits:</div>`);
    payLines.push(pay.paychecks.slice(-6).map(p => `<div class="chip"><span class="mono">${escapeHtml(p.dateISO)}</span> ${money(p.amount)} <span class="tag">${escapeHtml(p.name || p.merchant || "")}</span></div>`).join(""));
  }
  if (pay.spikes?.length) {
    payLines.push(`<div class="small" style="margin-top:8px;">Overtime / spikes:</div>`);
    payLines.push(pay.spikes.slice(-6).map(s => `<div class="chip"><span class="mono">${escapeHtml(s.dateISO)}</span> ${money(s.amount)} <span class="tag">+${money(s.delta)}</span></div>`).join(""));
  }
  els.paycheckList.innerHTML = payLines.join("") || `<div class="small hint">No paycheck pattern details yet.</div>`;

  const recon = buildReconciliation();
  els.reconLine.textContent = recon.line || "—";
  els.reconDetails.textContent = recon.details || "";

  // Credit card KPIs
  const ccStats = computeCardScopeStats(totals.scopeTxAll);
  const totalCCSpend = ccStats.reduce((s,x)=>s+x.spend,0);
  const totalCCPay = ccStats.reduce((s,x)=>s+x.payments,0);
  els.ccKpiLine.textContent = `CC Spend ${money(totalCCSpend)} • CC Payments ${money(totalCCPay)}`;

  // ===== CHANGE: add Balance + Limit back into the per-card table =====
  const ccTable = ccStats.map(x => {
    const name = x.card?.name || ("Card "+(x.card?.last4||""));
    const last4 = x.card?.last4 || "";
    const util = (x.util === null || x.util === undefined) ? "—" : `${Math.round(x.util*100)}%`;

    const balTxt = (x.balance === null || x.balance === undefined) ? "—" : money(x.balance);
    const limTxt = (x.limit === null || x.limit === undefined) ? "—" : money(x.limit);

    return `
      <tr>
        <td>${escapeHtml(name)} <span class="pill">•••• ${escapeHtml(last4)}</span></td>
        <td class="mono right">${money(x.spend)}</td>
        <td class="mono right">${money(x.payments)}</td>
        <td class="mono right">${moneySigned(x.net)}</td>
        <td class="mono right">${balTxt}</td>
        <td class="mono right">${limTxt}</td>
        <td class="mono right">${util}</td>
      </tr>
    `;
  }).join("");

  els.ccTableWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead>
          <tr>
            <th>Card</th>
            <th class="right">Spend</th>
            <th class="right">Payments</th>
            <th class="right">Net</th>
            <th class="right">Balance</th>
            <th class="right">Limit</th>
            <th class="right">Util</th>
          </tr>
        </thead>
        <tbody>${ccTable || ""}</tbody>
      </table>
    </div>
  `;
  // ===================================================================

  const payoff = payoffPlannerSummary();
  els.payoffHeadline.textContent = payoff.headline || "—";
  els.payoffDetails.innerHTML = payoff.details || "";

  renderCardSettings();
  renderCardsTrash();
  updateRulesTable();
  renderRulesTrash();

  populateImportCardDropdown();
}

/* =========================================================
   11) Event handlers
========================================================= */
els.viewMode.addEventListener("change", () => {
  updateViewModeUI();
  updateDashboard();
});
els.rangeStart.addEventListener("change", updateDashboard);
els.rangeEnd.addEventListener("change", updateDashboard);
els.monthSelect.addEventListener("change", updateDashboard);
els.chartMode.addEventListener("change", updateDashboard);

els.rangeToAllDataBtn.addEventListener("click", () => {
  const { minISO, maxISO } = getDataRange();
  if (minISO) els.rangeStart.value = minISO;
  if (maxISO) els.rangeEnd.value = maxISO;
  updateDashboard();
});
els.rangeLast90Btn.addEventListener("click", () => {
  const { maxISO } = getDataRange();
  if (!maxISO) return;
  els.rangeEnd.value = maxISO;
  els.rangeStart.value = isoAddDays(maxISO, -89);
  updateDashboard();
});
els.rangeThisMonthBtn.addEventListener("click", () => {
  const now = new Date();
  const month = yyyymmFromDate(now);
  els.rangeStart.value = `${month}-01`;
  const [y,m] = month.split("-").map(n=>parseInt(n,10));
  els.rangeEnd.value = new Date(y, m, 0).toISOString().slice(0,10);
  updateDashboard();
});

els.importAs.addEventListener("change", () => {
  updateImportUI();
});

els.importBtn.addEventListener("click", async () => {
  const file = els.fileInput.files?.[0];
  if (!file) { els.status.textContent = "Pick a CSV file first."; return; }

  let mode = els.importAs.value;
  if (mode === "auto") mode = inferImportMode(file.name) || "checking";

  let cardLast4 = null;
  if (mode === "credit") {
    cardLast4 = els.importCard.value || detectLast4FromFilename(file.name);
    if (!cardLast4) { els.status.textContent = "Select a card (last 4)."; return; }
  }

  try {
    els.status.textContent = "Importing...";
    const res = await importCSVFile(file, mode, cardLast4);
    els.status.textContent = `Imported: +${res.added} (skipped ${res.skipped}, failed ${res.failed})`;
    els.debug.textContent = res.debugRows.map(r => JSON.stringify(r)).join("\n");
    updateDashboard();
  } catch (e) {
    els.status.textContent = `Error: ${e.message || e}`;
  }
});

els.removeMarkersBtn.addEventListener("click", () => {
  if (!confirm("Remove ALL Starting Balance rows? This affects running balance anchors.")) return;
  allTransactions = allTransactions.filter(t => t.category !== "Starting Balance");
  saveAll();
  updateDashboard();
});

els.clearBtn.addEventListener("click", () => {
  if (!confirm("Start Fresh? This deletes transactions, rules, card profiles, and trash. This can't be undone.")) return;
  allTransactions = [];
  userRules = [];
  importMeta = [];
  cardProfiles = [];
  trashStore = { rules: [], cards: [], cardTx: [] };
  saveAll();
  updateDashboard();
});

// Rules controls
els.addRuleBtn.addEventListener("click", () => {
  const contains = (els.ruleContains.value || "").trim();
  const category = (els.ruleCategory.value || "").trim();
  if (!contains || !category) return;
  userRules.push({ contains, category });
  els.ruleContains.value = "";
  saveAll();
  updateRulesTable();
  recategorizeAll();
  updateDashboard();
});

els.reapplyRulesBtn.addEventListener("click", () => {
  recategorizeAll();
  updateDashboard();
});

els.selectAllRulesBtn.addEventListener("click", () => {
  const checks = els.rulesTableWrap.querySelectorAll('input[data-rulechk]');
  const allChecked = !!els.rulesTableWrap.querySelector('input[data-rulechk]') && Array.from(checks).every(c => c.checked);
  checks.forEach(c => c.checked = !allChecked);
  els.trashSelectedRulesBtn.disabled = !els.rulesTableWrap.querySelector('input[data-rulechk]:checked');
});

els.trashSelectedRulesBtn.addEventListener("click", () => {
  const checks = els.rulesTableWrap.querySelectorAll('input[data-rulechk]:checked');
  const idxs = Array.from(checks).map(c => Number(c.getAttribute("data-rulechk")));
  moveRulesToTrash(idxs);
});

els.clearRulesBtn.addEventListener("click", () => {
  if (!userRules.length) return;
  const idxs = userRules.map((_,i) => i);
  moveRulesToTrash(idxs);
});

els.clearRulesTrashBtn.addEventListener("click", () => {
  ensureTrashStoreShape();
  const n = (trashStore.rules || []).length;
  if (!n) return;
  if (!confirm(`Clear Rules Trash (${n} item(s)) permanently? This can't be undone.`)) return;
  trashStore.rules = [];
  saveAll();
  renderRulesTrash();
});

// Card settings controls
els.addCardBtn.addEventListener("click", () => {
  const last4 = prompt("Enter last 4 digits for the new card (e.g. 4321):");
  if (!last4 || !/^\d{4}$/.test(last4.trim())) {
    els.cardSettingsStatus.textContent = "Cancelled (need 4 digits).";
    return;
  }
  const name = prompt("Card name (optional):") || `Card ${last4.trim()}`;
  getOrCreateCardProfile(last4.trim(), name);
  els.cardSettingsStatus.textContent = `Added card ${last4.trim()}.`;
  populateImportCardDropdown(last4.trim());
  renderCardSettings();
  updateDashboard();
});

els.saveCardSettingsBtn.addEventListener("click", () => {
  readCardSettingsFromUI();
  saveAll();
  els.cardSettingsStatus.textContent = "Saved card settings.";
  setTimeout(()=>els.cardSettingsStatus.textContent="", 1200);
  updateDashboard();
});

els.selectAllCardsBtn.addEventListener("click", () => {
  const checks = els.cardSettingsWrap.querySelectorAll('input[data-cardchk]');
  const allChecked = !!els.cardSettingsWrap.querySelector('input[data-cardchk]') && Array.from(checks).every(c => c.checked);
  checks.forEach(c => c.checked = !allChecked);
  els.trashSelectedCardsBtn.disabled = !els.cardSettingsWrap.querySelector('input[data-cardchk]:checked');
});

els.trashSelectedCardsBtn.addEventListener("click", () => {
  const checks = els.cardSettingsWrap.querySelectorAll('input[data-cardchk]:checked');
  const idxs = Array.from(checks).map(c => Number(c.getAttribute("data-cardchk")));
  const alsoTx = !!els.trashCardsAlsoTxChk.checked;
  moveCardsToTrash(idxs, alsoTx);
  els.trashCardsAlsoTxChk.checked = false;
});

els.clearCardsTrashBtn.addEventListener("click", () => {
  ensureTrashStoreShape();
  const n = (trashStore.cards || []).length;
  if (!n) return;
  if (!confirm(`Clear Credit Cards Trash (${n} item(s)) permanently?\n\nThis will also delete any saved transaction bundles for restore (if present). This can't be undone.`)) return;

  trashStore.cards = [];
  trashStore.cardTx = [];
  saveAll();
  renderCardsTrash();
});

/* =========================================================
   12) Init
========================================================= */
(function init(){
  ensureDefaultCards();
  ensureTrashStoreShape();

  populateImportCardDropdown();
  updateImportUI();
  renderCardSettings();
  updateRulesTable();
  renderCardsTrash();
  renderRulesTrash();
  updateDashboard();

/* ===================== Fidelity Phase 2 logic (holdings snapshots) ===================== */
function ensureFidelitySnapshotsShape() {
  let snaps = [];
  try { snaps = JSON.parse(localStorage.getItem("fidelitySnapshots") || "[]"); } catch { snaps = []; }
  if (!Array.isArray(snaps)) snaps = [];
  return snaps;
}

function saveFidelitySnapshots(snaps) {
  localStorage.setItem("fidelitySnapshots", JSON.stringify(snaps || []));
}

function makeSnapId() {
  return "fs-" + Date.now() + "-" + Math.random().toString(16).slice(2);
}

function parsePercent(value) {
  const s = String(value || "").trim();
  if (!s) return null;
  const n = Number(s.replace(/%/g, "").replace(/,/g, "").trim());
  return Number.isNaN(n) ? null : n;
}

function parseMonthFromAbbrev(m) {
  const map = { jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12 };
  return map[String(m||"").toLowerCase().slice(0,3)] || null;
}

function inferAsOfFromFilename(name) {
  const s = String(name || "");
  // Match Feb-15-2026 or Feb_15_2026 or Feb 15 2026
  const m = s.match(/([A-Za-z]{3})[-_\s](\d{1,2})[-_\s](\d{4})/);
  if (!m) return null;
  const mm = parseMonthFromAbbrev(m[1]);
  const dd = parseInt(m[2], 10);
  const yyyy = parseInt(m[3], 10);
  if (!mm || !dd || !yyyy) return null;
  const iso = `${yyyy}-${String(mm).padStart(2,"0")}-${String(dd).padStart(2,"0")}`;
  return iso;
}

function parseFidelityPositionsCSV(text) {
  // Uses existing parseCSV/parseMoney helpers from the app.
  const rows = parseCSV(text);
  if (!rows.length) throw new Error("CSV looks empty.");

  // Find header row by required columns
  let headerIdx = -1;
  for (let i=0; i<Math.min(rows.length, 25); i++) {
    const r = rows[i] || [];
    const joined = r.map(x=>String(x||"").trim().toLowerCase()).join("|");
    if (joined.includes("account number") && joined.includes("symbol") && joined.includes("current value")) {
      headerIdx = i;
      break;
    }
  }
  if (headerIdx < 0) headerIdx = 0;

  const header = (rows[headerIdx] || []).map(h => (h || "").trim());
  const iAcctNum = indexOfAny(header, ["Account Number"]);
  const iAcctName= indexOfAny(header, ["Account Name"]);
  const iSymbol  = indexOfAny(header, ["Symbol"]);
  const iDesc    = indexOfAny(header, ["Description"]);
  const iQty     = indexOfAny(header, ["Quantity"]);
  const iLast    = indexOfAny(header, ["Last Price"]);
  const iValue   = indexOfAny(header, ["Current Value"]);
  const iPct     = indexOfAny(header, ["Percent Of Account"]);
  const iCostTot = indexOfAny(header, ["Cost Basis Total"]);
  const iAvgCost = indexOfAny(header, ["Average Cost Basis"]);
  const iGLDol   = indexOfAny(header, ["Total Gain/Loss Dollar"]);
  const iGLPct   = indexOfAny(header, ["Total Gain/Loss Percent"]);
  const iType    = indexOfAny(header, ["Type"]);

  if (iSymbol < 0 || iValue < 0) throw new Error("Fidelity CSV missing required columns (Symbol, Current Value).");

  const positions = [];
  let acctNumber = null;
  let acctName = null;

  for (const r of rows.slice(headerIdx+1)) {
    const symbolRaw = (r[iSymbol] ?? "").trim();
    const descRaw = (iDesc >= 0 ? (r[iDesc] ?? "").trim() : "");

    // Stop at footer/disclaimer region
    const maybeDisclaimer = (symbolRaw + " " + descRaw).toLowerCase();
    if (maybeDisclaimer.includes("the data and information in this spreadsheet")) break;
    if (maybeDisclaimer.includes("brokerage services are provided by fidelity")) break;
    if (maybeDisclaimer.includes("date downloaded")) break;

    // Skip fully empty rows
    const anyContent = r.some(cell => String(cell || "").trim() !== "");
    if (!anyContent) continue;

    // Skip pending activity row
    if (symbolRaw.toLowerCase() === "pending activity") continue;

    // Record account info from the first real row
    if (!acctNumber && iAcctNum >= 0) acctNumber = (r[iAcctNum] ?? "").trim() || null;
    if (!acctName && iAcctName >= 0) acctName = (r[iAcctName] ?? "").trim() || null;

    // Some lines might have blank symbol but text in desc; ignore those
    if (!symbolRaw) continue;

    const qty = (iQty >= 0) ? Number(String(r[iQty] ?? "").replace(/,/g,"").trim() || "0") : null;
    const lastPrice = (iLast >= 0) ? parseMoney(r[iLast]) : null;
    const marketValue = parseMoney(r[iValue]);

    // Skip rows with no value
    if (marketValue === null) continue;

    const pct = (iPct >= 0) ? parsePercent(r[iPct]) : null;
    const costTotal = (iCostTot >= 0) ? parseMoney(r[iCostTot]) : null;
    const avgCost = (iAvgCost >= 0) ? parseMoney(r[iAvgCost]) : null;
    const glDol = (iGLDol >= 0) ? parseMoney(r[iGLDol]) : null;
    const glPct = (iGLPct >= 0) ? parsePercent(r[iGLPct]) : null;
    const type = (iType >= 0) ? (r[iType] ?? "").trim() : "";

    positions.push({
      symbol: symbolRaw,
      description: descRaw,
      shares: Number.isFinite(qty) ? qty : null,
      lastPrice,
      marketValue,
      percentOfAccount: pct,
      costBasisTotal: costTotal,
      averageCostBasis: avgCost,
      totalGainLossDollar: glDol,
      totalGainLossPercent: glPct,
      type
    });
  }

  const totalValue = positions.reduce((s,p)=>s + Number(p.marketValue || 0), 0);
  return { acctNumber, acctName, totalValue, positions };
}

function formatISOForHuman(iso) {
  if (!iso) return "";
  try {
    const d = new Date(iso + "T00:00:00");
    return d.toLocaleDateString();
  } catch {
    return iso;
  }
}

function renderFidelitySnapshotUI() {
  const snaps = ensureFidelitySnapshotsShape();
  const countEl = document.getElementById("fidSnapCount");
  if (countEl) countEl.textContent = String(snaps.length);

  const valueEl = document.getElementById("fidPortfolioValue");
  const subEl = document.getElementById("fidPortfolioSub");
  const pieCanvas = document.getElementById("fidPieCanvas");
  const pieSummary = document.getElementById("fidPieSummary");
  const tableWrap = document.getElementById("fidHoldingsTable");
  const historyWrap = document.getElementById("fidSnapHistory");

  if (!valueEl || !subEl || !pieCanvas || !tableWrap || !historyWrap) return;

  if (!snaps.length) {
    valueEl.textContent = money(0);
    valueEl.classList.remove("pos","neg");
    subEl.textContent = "No snapshots yet.";
    tableWrap.innerHTML = `<div class="small hint">Import a Fidelity positions CSV to populate holdings.</div>`;
    historyWrap.innerHTML = `<div class="small">No snapshots yet.</div>`;
    if (pieSummary) pieSummary.textContent = "";
    const ctx = pieCanvas.getContext("2d");
    ctx.clearRect(0,0,pieCanvas.width,pieCanvas.height);
    ctx.fillStyle = "#0f1726";
    ctx.fillRect(0,0,pieCanvas.width,pieCanvas.height);
    ctx.fillStyle = "#9fb0d0";
    ctx.font = "600 14px -apple-system,BlinkMacSystemFont,system-ui,sans-serif";
    ctx.fillText("No snapshot data yet.", 18, 30);
    return;
  }

  // Sort by asOfDateISO (fallback importedAtISO)
  const sorted = snaps.slice().sort((a,b)=>{
    const ad = (a.asOfDateISO || "").localeCompare(b.asOfDateISO || "");
    if (ad !== 0) return ad;
    return (a.importedAtISO || "").localeCompare(b.importedAtISO || "");
  });
  const latest = sorted[sorted.length - 1];
  const prev = sorted.length >= 2 ? sorted[sorted.length - 2] : null;

  const latestVal = Number(latest.totalValue || 0);
  valueEl.textContent = money(latestVal);
  valueEl.classList.remove("pos","neg");

  let sub = `As of ${formatISOForHuman(latest.asOfDateISO)} · ${latest.positions?.length || 0} positions`;
  if (prev) {
    const prevVal = Number(prev.totalValue || 0);
    const delta = latestVal - prevVal;
    const pct = prevVal ? (delta / prevVal) * 100 : null;
    const deltaText = `${moneySigned(delta)}${(pct !== null ? ` (${(pct>=0?"+":"")}${pct.toFixed(2)}%)` : "")}`;
    sub += ` · Change vs prior snapshot: ${deltaText}`;
    if (subEl) subEl.classList.remove("pos","neg");
    if (delta > 0) subEl.classList.add("pos");
    else if (delta < 0) subEl.classList.add("neg");
  } else {
    if (subEl) subEl.classList.remove("pos","neg");
  }
  subEl.textContent = sub;

  // Build allocation data from marketValue (top 10 + Other)
  const positions = (latest.positions || []).slice().filter(p => Number(p.marketValue || 0) !== 0);
  const alloc = positions.map(p => ({ label: p.symbol || "Unknown", value: Math.abs(Number(p.marketValue || 0)) }));
  alloc.sort((a,b)=>b.value-a.value);
  const top = alloc.slice(0,10);
  const otherSum = alloc.slice(10).reduce((s,x)=>s+x.value,0);
  const pieData = otherSum > 0 ? top.concat([{ label:"Other", value: otherSum }]) : top;

  drawPieWithLegend(pieCanvas, pieData, "Fidelity Allocation (Latest Snapshot)", 10);
  if (pieSummary) {
    pieSummary.textContent = `Top holding: ${top[0]?.label || "—"} (${money(top[0]?.value || 0)})`;
  }

  // Holdings table
  const rows = positions
    .slice()
    .sort((a,b)=>Number(b.marketValue||0) - Number(a.marketValue||0))
    .map(p => {
      const pct = latestVal ? (Number(p.marketValue||0) / latestVal) * 100 : null;
      const glDol = (p.totalGainLossDollar === null || p.totalGainLossDollar === undefined) ? null : Number(p.totalGainLossDollar);
      const glPct = (p.totalGainLossPercent === null || p.totalGainLossPercent === undefined) ? null : Number(p.totalGainLossPercent);
      const glClass = (glDol !== null && glDol < 0) ? "neg" : (glDol !== null && glDol > 0 ? "pos" : "");
      return `
        <tr>
          <td class="mono">${escapeHtml(p.symbol || "")}</td>
          <td>${escapeHtml(p.description || "")}</td>
          <td class="mono right">${(p.shares === null || p.shares === undefined) ? "—" : escapeHtml(String(p.shares))}</td>
          <td class="mono right">${money(p.marketValue || 0)}</td>
          <td class="mono right">${pct === null ? "—" : pct.toFixed(2) + "%"}</td>
          <td class="mono right">${p.costBasisTotal === null ? "—" : money(p.costBasisTotal)}</td>
          <td class="mono right ${glClass}">${glDol === null ? "—" : moneySigned(glDol)}${(glPct === null ? "" : ` (${(glPct>=0?"+":"")}${glPct.toFixed(2)}%)`)}</td>
        </tr>
      `;
    }).join("");

  tableWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Description</th>
            <th class="right">Shares</th>
            <th class="right">Value</th>
            <th class="right">%</th>
            <th class="right">Cost Basis</th>
            <th class="right">Total G/L</th>
          </tr>
        </thead>
        <tbody>${rows || ""}</tbody>
      </table>
    </div>
  `;

  // History table
  const histRows = sorted.slice().reverse().slice(0,12).map(s => {
    const v = Number(s.totalValue || 0);
    const label = formatISOForHuman(s.asOfDateISO) || formatDateTime(s.importedAtISO);
    const id = s.snapshotId;
    return `
      <tr>
        <td class="mono">${escapeHtml(label)}</td>
        <td class="mono right">${money(v)}</td>
        <td class="mono">${escapeHtml(s.sourceFileName || "")}</td>
        <td class="right"><button class="danger" data-del-snap="${escapeHtml(id)}">Delete</button></td>
      </tr>
    `;
  }).join("");

  historyWrap.innerHTML = `
    <div style="overflow:auto;">
      <table>
        <thead><tr><th>As of</th><th class="right">Value</th><th>Source</th><th class="right"></th></tr></thead>
        <tbody>${histRows || ""}</tbody>
      </table>
    </div>
  `;

  historyWrap.querySelectorAll("button[data-del-snap]").forEach(btn => {
    btn.addEventListener("click", () => {
      const id = btn.getAttribute("data-del-snap");
      if (!confirm("Delete this Fidelity snapshot? This can't be undone.")) return;
      const snapsNow = ensureFidelitySnapshotsShape().filter(x => x.snapshotId !== id);
      saveFidelitySnapshots(snapsNow);
      renderFidelitySnapshotUI();
    });
  });
}

function wireFidelityImport() {
  const fileInput = document.getElementById("fidelityPositionsFile");
  const dateInput = document.getElementById("fidelityAsOfDate");
  const btn = document.getElementById("importFidelityPositionsBtn");
  const statusEl = document.getElementById("fidelityImportStatus");

  if (!fileInput || !btn) return;

  btn.addEventListener("click", async () => {
    try {
      const file = fileInput.files && fileInput.files[0];
      if (!file) { if(statusEl) statusEl.textContent = "Choose a Fidelity CSV first."; return; }

      const asOf = (dateInput && dateInput.value) ? dateInput.value : (inferAsOfFromFilename(file.name) || new Date().toISOString().slice(0,10));
      const text = await file.text();
      const parsed = parseFidelityPositionsCSV(text);

      const snapshot = {
        snapshotId: makeSnapId(),
        asOfDateISO: asOf,
        importedAtISO: new Date().toISOString(),
        sourceFileName: file.name,
        accountNumber: parsed.acctNumber || null,
        accountName: parsed.acctName || null,
        totalValue: parsed.totalValue,
        positions: parsed.positions
      };

      // Dedupe: same asOfDateISO + same totalValue + same positions length
      let snaps = ensureFidelitySnapshotsShape();
      const dupe = snaps.some(s =>
        String(s.asOfDateISO||"") === String(snapshot.asOfDateISO||"") &&
        Math.abs(Number(s.totalValue||0) - Number(snapshot.totalValue||0)) < 0.01 &&
        Number((s.positions||[]).length) === Number((snapshot.positions||[]).length)
      );
      if (dupe) {
        if(statusEl) statusEl.textContent = `Snapshot for ${asOf} looks like a duplicate. Not imported.`;
        renderFidelitySnapshotUI();
        return;
      }

      snaps.push(snapshot);
      saveFidelitySnapshots(snaps);

      if(statusEl) statusEl.textContent = `Imported snapshot: ${asOf} · ${snapshot.positions.length} positions · Total ${money(snapshot.totalValue)}`;

      renderFidelitySnapshotUI();
    } catch (e) {
      if(statusEl) statusEl.textContent = "Import failed: " + (e && e.message ? e.message : String(e));
    }
  });
}

/* Ensure Phase 2 UI is wired after DOM is ready */
document.addEventListener("DOMContentLoaded", () => {
  wireFidelityImport();
  renderFidelitySnapshotUI();
});
/* ===================================================================================== */

})();
</script>





<script>
(function(){

function detectPattern(dates){
  if(dates.length<3) return "Not enough data";
  const intervals=[];
  for(let i=1;i<dates.length;i++){
    const d1=new Date(dates[i-1]);
    const d2=new Date(dates[i]);
    intervals.push(Math.round((d2-d1)/(1000*60*60*24)));
  }
  const median=arr=>{
    const a=arr.slice().sort((x,y)=>x-y);
    const m=Math.floor(a.length/2);
    return a.length%2?a[m]:(a[m-1]+a[m])/2;
  };
  const med=median(intervals);
  if(med>=13 && med<=15) return "Biweekly pattern";
  if(med>=27 && med<=33) return "Monthly pattern";
  return "Irregular pattern";
}

function updateInvestingModule(scopeTx, allTx){

  const invAll = allTx.filter(t =>
    t.accountId==="checking" &&
    t.category==="Investing"
  );

  const invScope = scopeTx.filter(t =>
    t.accountId==="checking" &&
    t.category==="Investing"
  );

  const lifetimeContrib = invAll.filter(t=>t.amount<0)
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const lifetimeWithdraw = invAll.filter(t=>t.amount>0)
    .reduce((s,t)=>s+t.amount,0);

  const lifetimeNet = lifetimeContrib - lifetimeWithdraw;

  const lifetimeEl = document.getElementById("invLifetime");
  if(lifetimeEl){
    lifetimeEl.textContent = lifetimeNet.toLocaleString("en-US",{style:"currency",currency:"USD"});
    lifetimeEl.className = lifetimeNet>=0?"v pos":"v neg";
  }

  const scopeContrib = invScope.filter(t=>t.amount<0)
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const scopeWithdraw = invScope.filter(t=>t.amount>0)
    .reduce((s,t)=>s+t.amount,0);

  const scopeNet = scopeContrib - scopeWithdraw;

  const setMoney = (id,val,signed=false)=>{
    const el=document.getElementById(id);
    if(!el) return;
    if(signed){
      const prefix = val>0?"+":"";
      el.textContent = prefix + val.toLocaleString("en-US",{style:"currency",currency:"USD"});
      el.className = val>=0?"v pos":"v neg";
    }else{
      el.textContent = val.toLocaleString("en-US",{style:"currency",currency:"USD"});
    }
  };

  setMoney("invContrib",scopeContrib);
  setMoney("invWithdraw",scopeWithdraw);
  setMoney("invNet",scopeNet,true);

  const last = invAll.filter(t=>t.amount<0)
    .sort((a,b)=>b.dateISO.localeCompare(a.dateISO))[0];

  const lastEl=document.getElementById("invLast");
  if(lastEl){
    lastEl.textContent = last
      ? Math.abs(last.amount).toLocaleString("en-US",{style:"currency",currency:"USD"}) + " on " + last.dateISO
      : "—";
  }

  const contribDates = invAll.filter(t=>t.amount<0)
    .map(t=>t.dateISO)
    .sort();

  const patEl=document.getElementById("invPattern");
  if(patEl){
    patEl.textContent = detectPattern(contribDates);
  }

  const monthly={};
  invAll.filter(t=>t.amount<0).forEach(t=>{
    monthly[t.month]=(monthly[t.month]||0)+Math.abs(t.amount);
  });

  const sortedMonths=Object.keys(monthly).sort().reverse();
  const list=sortedMonths.map(m=>m+": "+
    monthly[m].toLocaleString("en-US",{style:"currency",currency:"USD"})
  ).join("<br>");

  const monthlyEl=document.getElementById("invMonthly");
  if(monthlyEl){
    monthlyEl.innerHTML = list || "No data";
  }
}

// Wrap existing updateDashboard WITHOUT modifying original code
if(typeof window.updateDashboard==="function"){
  const originalUpdateDashboard=window.updateDashboard;
  window.updateDashboard=function(){
    originalUpdateDashboard.apply(this,arguments);
    const scope = getScope();
    const scopeTx = filterToScope(allTransactions, scope);
    updateInvestingModule(scopeTx, allTransactions);
    // Phase 2: holdings snapshots UI
    try { renderFidelitySnapshotUI(); } catch {}
};
}

})();
</script>
</body>
</html>
