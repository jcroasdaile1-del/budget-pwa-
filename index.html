<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b1220" />
  <title>Budget Command Center</title>

  <style>
    body { margin:0; font-family:-apple-system,BlinkMacSystemFont,system-ui,sans-serif; background:#0b1220; color:#e8eefc; padding:16px; }
    h1 { font-size:18px; margin:0 0 12px; }
    .card { background:#121a2b; padding:16px; border-radius:12px; margin-bottom:16px; border:1px solid #24314f; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-start; }
    button { padding:10px 14px; border-radius:10px; border:none; font-weight:900; cursor:pointer; }
    .primary { background:#64d2ff; color:#0b1220; }
    .danger { background:#ff6b6b; color:#fff; }
    .ghost { background:#0f1726; color:#e8eefc; border:1px solid #24314f; }
    input, select { padding:10px; border-radius:10px; border:1px solid #24314f; background:#0f1726; color:#e8eefc; width:100%; }
    label { font-size:12px; color:#9fb0d0; display:block; margin-bottom:6px; }
    table { width:100%; font-size:12px; border-collapse:collapse; }
    th, td { padding:8px 6px; border-bottom:1px solid #24314f; vertical-align:top; }
    th { color:#9fb0d0; text-align:left; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #24314f; border-radius:999px; color:#9fb0d0; font-size:11px; }
    .pos { color:#6bff95; }
    .neg { color:#ff6b6b; }
    .small { font-size:12px; color:#9fb0d0; line-height:1.4; margin:8px 0 0; }
    .kpi { font-size:34px; font-weight:950; margin:6px 0 0; letter-spacing:-.5px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap:10px; }
    @media(min-width:820px){ .grid2 { grid-template-columns: 1fr 1fr; } }
    .kpiBox { background:#0f1726; border:1px solid #24314f; border-radius:12px; padding:12px; }
    .kpiBox .t { color:#9fb0d0; font-size:12px; }
    .kpiBox .v { font-size:20px; font-weight:900; margin-top:6px; }
    .hint { color:#9fb0d0; font-size:12px; }
  </style>
</head>

<body>
  <h1>Budget Command Center</h1>

  <!-- TOP SUMMARY (always shows month totals; balance is shown if available) -->
  <div class="card">
    <div class="row">
      <div style="min-width:300px;">
        <div class="pill">Month Summary</div>
        <div id="topLine" class="kpi">$0.00</div>
        <div id="topSub" class="small"></div>
        <div id="balanceSub" class="small"></div>
      </div>

      <div style="min-width:220px;">
        <label for="monthSelect">Month view</label>
        <input id="monthSelect" type="month" />
      </div>
    </div>

    <p class="small">
      <b>How balance works:</b><br/>
      • If your CSV already has a <span class="mono">Balance</span> (or <span class="mono">Running Balance</span>) column, this app will use it automatically (start = earliest balance in month, end = latest).<br/>
      • If your CSV does <i>not</i> have a balance column, you can add one “Starting Balance” marker line by putting the words <span class="mono">starting balance</span> in <span class="mono">Name</span> or <span class="mono">Memo</span> and the number in <span class="mono">Amount</span>.
    </p>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Month Totals (Selected Month)</h3>

    <div class="grid2">
      <div class="kpiBox">
        <div class="t">Income (Credits)</div>
        <div id="income" class="v pos">$0.00</div>
        <div class="hint">Sum of positive amounts</div>
      </div>

      <div class="kpiBox">
        <div class="t">Outflows (Debits)</div>
        <div id="outflows" class="v neg">$0.00</div>
        <div class="hint">Sum of absolute value of negatives</div>
      </div>

      <div class="kpiBox">
        <div class="t">Spending (Transfers Excluded)</div>
        <div id="spending" class="v neg">$0.00</div>
        <div class="hint">Debits excluding transfers + excluding marker rows</div>
      </div>

      <div class="kpiBox">
        <div class="t">Transfers (Net)</div>
        <div id="transfers" class="v">$0.00</div>
        <div class="hint">Net of transfer-labeled items</div>
      </div>

      <div class="kpiBox">
        <div class="t">Net Change (All Real Tx)</div>
        <div id="netChange" class="v">$0.00</div>
        <div class="hint">Income − debits (includes transfers). Excludes marker rows.</div>
      </div>

      <div class="kpiBox">
        <div class="t">Balance (If Provided)</div>
        <div id="balanceBox" class="v">$0.00</div>
        <div id="balanceHint" class="hint"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px;">Import CSV</h3>
    <input type="file" id="fileInput" accept=".csv,text/csv" />
    <div class="btnRow" style="margin-top:10px;">
      <button class="primary" id="importBtn">Import (Add to History)</button>
      <button class="ghost" id="resetMonthBtn">Reset THIS Month (remove markers + ignore balances for month)</button>
      <button class="danger" id="clearBtn">Start Fresh (Delete Everything)</button>
    </div>

    <p id="status" class="small"></p>
    <div id="debug" class="small mono"></div>

    <p class="small">
      <b>Reset options:</b><br/>
      • <b>Reset THIS Month</b> removes any “starting balance” marker rows you added for the selected month and clears any stored balance overrides for that month.<br/>
      • <b>Start Fresh</b> deletes all imported data so you can begin again.
    </p>
  </div>

  <div class="card">
    <div class="row">
      <h3 style="margin:0;">Transactions (Selected Month)</h3>
      <span id="countPill" class="pill">0 tx</span>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Name</th>
            <th>Memo</th>
            <th>Type</th>
            <th>Category</th>
            <th class="mono">Amount</th>
            <th class="mono">Balance</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

<script>
/* =========================
   Robust CSV parser (quoted commas safe)
========================= */
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"') {
      if (inQuotes && next === '"') { cur += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (c === ',' && !inQuotes) {
      row.push(cur);
      cur = "";
    } else if ((c === '\n' || c === '\r') && !inQuotes) {
      if (c === '\r' && next === '\n') i++;
      row.push(cur);
      cur = "";
      if (row.some(cell => cell.trim() !== "")) rows.push(row);
      row = [];
    } else {
      cur += c;
    }
  }
  if (cur.length || row.length) {
    row.push(cur);
    rows.push(row);
  }
  return rows;
}

/* =========================
   Dates & money
========================= */
function parseUSDate(mmddyyyy) {
  const s = (mmddyyyy || "").trim();
  const parts = s.split("/");
  if (parts.length !== 3) return null;
  const mm = parseInt(parts[0], 10);
  const dd = parseInt(parts[1], 10);
  const yyyy = parseInt(parts[2], 10);
  if (!mm || !dd || !yyyy) return null;
  const d = new Date(yyyy, mm - 1, dd);
  if (Number.isNaN(d.getTime())) return null;
  return d;
}
function yyyymmFromDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  return `${y}-${m}`;
}
function money(n) {
  return Number(n || 0).toLocaleString("en-US", { style: "currency", currency: "USD" });
}
function parseMoney(value) {
  if (value === null || value === undefined) return null;
  let s = String(value).trim();
  if (!s) return null;

  const isParenNeg = s.startsWith("(") && s.endsWith(")");
  if (isParenNeg) s = s.slice(1, -1);

  s = s.replace(/\$/g, "").replace(/,/g, "").trim();
  const n = Number(s);
  if (Number.isNaN(n)) return null;
  return isParenNeg ? -n : n;
}

/* =========================
   Storage
========================= */
let allTransactions = JSON.parse(localStorage.getItem("transactions") || "[]");

/**
 * monthOverrides lets you “reset” a month without deleting history.
 * { "YYYY-MM": { ignoreBalance: true } }
 */
let monthOverrides = JSON.parse(localStorage.getItem("monthOverrides") || "{}");

function saveAll() {
  localStorage.setItem("transactions", JSON.stringify(allTransactions));
  localStorage.setItem("monthOverrides", JSON.stringify(monthOverrides));
}

/* =========================
   Header mapping
========================= */
function indexOfAny(headers, candidates) {
  const upper = headers.map(h => (h || "").trim().toUpperCase());
  for (const c of candidates) {
    const idx = upper.indexOf(c.toUpperCase());
    if (idx >= 0) return idx;
  }
  return -1;
}

/* =========================
   Categorization / markers
========================= */
function isStartingBalanceMarker(name, memo, type) {
  const n = (name || "").toLowerCase();
  const m = (memo || "").toLowerCase();
  const t = (type || "").toLowerCase();
  return n.includes("starting balance") || m.includes("starting balance") || t === "balance";
}

function categorize(type, name, memo, amount) {
  const t = (type || "").toUpperCase();
  const n = (name || "").toUpperCase();
  const m = (memo || "").toUpperCase();

  if (isStartingBalanceMarker(name, memo, type)) return "Starting Balance";

  // Transfers (very basic heuristics; we can refine later)
  if (n.includes("PAYMENT TO CREDIT CARD") || n.includes("CREDIT CARD PAYMENT") || n.includes("CREDIT CARD")) return "Transfer";
  if (m.includes("PAYMENT TO CREDIT CARD") || m.includes("CREDIT CARD PAYMENT")) return "Transfer";

  // Starter buckets
  if (n.includes("FIDELITY") || n.includes("FID BKG") || m.includes("FIDELITY") || m.includes("FID BKG")) return "Investing";
  if (n.includes("SPECTRUM") || m.includes("SPECTRUM")) return "Utilities";
  if (n.includes("US CELL") || n.includes("USCELL") || m.includes("USCELL")) return "Phone";
  if (n.includes("KWIK TRIP") || n.includes("EXXON") || m.includes("KWIK TRIP") || m.includes("EXXON")) return "Gas";
  if (n.includes("AMAZON") || m.includes("AMAZON")) return "Shopping";
  if (n.includes("PICK N SAVE") || m.includes("PICK N SAVE")) return "Groceries";

  // Income guess
  if (t === "CREDIT" && (n.includes("PAYROLL") || m.includes("PAYROLL") || n.includes("DEPOSIT") || m.includes("DEPOSIT"))) return "Income";

  return amount < 0 ? "Discretionary" : "Other";
}

/* =========================
   Import
   - Uses existing Balance column if present (Balance/Running Balance)
   - Still supports marker rows via Name/Memo (fallback)
========================= */
async function importCSVFile(file) {
  const text = await file.text();
  const rows = parseCSV(text);
  if (rows.length < 2) throw new Error("CSV looks empty.");

  const header = rows[0].map(h => (h || "").trim());

  const iDate = indexOfAny(header, ["Date", "Posting Date", "Transaction Date"]);
  const iType = indexOfAny(header, ["Transaction", "Type"]);
  const iName = indexOfAny(header, ["Name", "Merchant", "Description"]);
  const iMemo = indexOfAny(header, ["Memo", "Details", "Note"]);
  const iAmount = indexOfAny(header, ["Amount", "Transaction Amount"]);
  const iBalance = indexOfAny(header, ["Balance", "Running Balance", "Account Balance"]);

  if (iDate < 0 || iName < 0 || iAmount < 0) {
    throw new Error("Missing required columns. Need at least: Date + Name/Merchant + Amount.");
  }

  let added = 0, skipped = 0, failed = 0;
  const debugRows = [];

  for (const r of rows.slice(1)) {
    try {
      const dateStr = (r[iDate] ?? "").trim();
      const type = (iType >= 0 ? (r[iType] ?? "").trim() : "").toUpperCase();
      const name = (r[iName] ?? "").trim();
      const memo = (iMemo >= 0 ? (r[iMemo] ?? "").trim() : "");
      const amount = parseMoney(r[iAmount]);
      const bal = (iBalance >= 0) ? parseMoney(r[iBalance]) : null;

      const d = parseUSDate(dateStr);
      if (!d || amount === null) { failed++; continue; }

      const month = yyyymmFromDate(d);
      const dateISO = d.toISOString().slice(0, 10);

      const category = categorize(type, name, memo, amount);

      // Dedup: date + name + memo + amount + type + balance
      // (balance included so repeated exports with different balance formatting won't duplicate wrongly)
      const key = `${dateISO}|${name}|${memo}|${amount.toFixed(2)}|${type || ""}|${bal === null ? "NA" : bal.toFixed(2)}`;
      const exists = allTransactions.some(t => t.key === key);
      if (exists) { skipped++; continue; }

      const record = { key, dateISO, month, type, name, memo, amount, balance: bal, category };
      allTransactions.push(record);
      added++;

      if (debugRows.length < 4) debugRows.push(record);
    } catch {
      failed++;
    }
  }

  saveAll();
  return { added, skipped, failed, debugRows, hasBalanceColumn: (iBalance >= 0) };
}

/* =========================
   Dashboard
========================= */
const els = {
  monthSelect: document.getElementById("monthSelect"),
  topLine: document.getElementById("topLine"),
  topSub: document.getElementById("topSub"),
  balanceSub: document.getElementById("balanceSub"),

  income: document.getElementById("income"),
  outflows: document.getElementById("outflows"),
  spending: document.getElementById("spending"),
  transfers: document.getElementById("transfers"),
  netChange: document.getElementById("netChange"),
  balanceBox: document.getElementById("balanceBox"),
  balanceHint: document.getElementById("balanceHint"),

  fileInput: document.getElementById("fileInput"),
  importBtn: document.getElementById("importBtn"),
  resetMonthBtn: document.getElementById("resetMonthBtn"),
  clearBtn: document.getElementById("clearBtn"),
  status: document.getElementById("status"),
  debug: document.getElementById("debug"),

  countPill: document.getElementById("countPill"),
  tableBody: document.getElementById("tableBody")
};

function getSelectedMonth() {
  return els.monthSelect.value || yyyymmFromDate(new Date());
}

function updateDashboard() {
  const sel = getSelectedMonth();
  const overrides = monthOverrides[sel] || {};
  const monthTx = allTransactions.filter(t => t.month === sel);

  // Marker rows
  const markerRows = monthTx.filter(t => t.category === "Starting Balance");

  // "Real" tx excludes marker rows
  const realTx = monthTx.filter(t => t.category !== "Starting Balance");

  // Totals ALWAYS computed even if balance missing
  const totalIncome = realTx.filter(t => t.amount > 0).reduce((s,t)=>s+t.amount,0);
  const totalOutflows = realTx.filter(t => t.amount < 0).reduce((s,t)=>s+Math.abs(t.amount),0);

  const transferOut = realTx.filter(t => t.category === "Transfer" && t.amount < 0).reduce((s,t)=>s+Math.abs(t.amount),0);
  const transferIn  = realTx.filter(t => t.category === "Transfer" && t.amount > 0).reduce((s,t)=>s+t.amount,0);
  const transferNet = transferIn - transferOut;

  const spending = realTx
    .filter(t => t.amount < 0)
    .filter(t => t.category !== "Transfer")
    .reduce((s,t)=>s+Math.abs(t.amount),0);

  const netChangeAll = realTx.reduce((s,t)=>s + Number(t.amount || 0), 0);

  // BALANCE selection logic:
  // 1) If NOT overridden, and there are numeric balances in rows, use earliest & latest balance in month.
  // 2) Else fallback to marker row amount as "start", then compute end = start + netChange.
  const balanceRows = overrides.ignoreBalance
    ? []
    : monthTx.filter(t => typeof t.balance === "number" && !Number.isNaN(t.balance));

  let startBal = null;
  let endBal = null;
  let balanceMode = "";

  if (balanceRows.length) {
    const sorted = balanceRows.slice().sort((a,b) => a.dateISO > b.dateISO ? 1 : -1);
    startBal = sorted[0].balance;
    endBal = sorted[sorted.length - 1].balance;
    balanceMode = `From Balance column (start ${sorted[0].dateISO}, end ${sorted[sorted.length - 1].dateISO})`;
  } else {
    // fallback to marker
    const markersSorted = markerRows.slice().sort((a,b)=>a.dateISO > b.dateISO ? 1 : -1);
    if (markersSorted.length) {
      startBal = markersSorted[0].amount;
      endBal = startBal + netChangeAll;
      balanceMode = `From “starting balance” marker row (${markersSorted[0].dateISO}) + computed net change`;
    } else {
      balanceMode = "No balance available (no Balance column values and no marker row)";
    }
  }

  // Render totals
  els.income.textContent = money(totalIncome);
  els.outflows.textContent = money(totalOutflows);
  els.spending.textContent = money(spending);
  els.transfers.textContent = money(transferNet);
  els.netChange.textContent = money(netChangeAll);

  // Top KPI: show Spending by default (what most people want monthly), and if balance exists show end balance
  els.topLine.textContent = money(spending);
  els.topSub.textContent = `Spending this month (transfers excluded) • ${sel}`;
  if (endBal !== null) {
    els.balanceSub.textContent = `End balance: ${money(endBal)} • ${balanceMode}`;
  } else {
    els.balanceSub.textContent = `Balance: unavailable • ${balanceMode}`;
  }

  // Balance box
  if (endBal === null) {
    els.balanceBox.textContent = "(missing)";
    els.balanceHint.textContent = balanceMode + ". If your CSV already has a Balance column, make sure it’s numeric (e.g., 1234.56 or $1,234.56).";
  } else {
    els.balanceBox.textContent = money(endBal);
    els.balanceHint.textContent = balanceMode;

    // sanity check: compare (end-start) vs netChange for month (excluding markers)
    if (startBal !== null && balanceRows.length) {
      const impliedNet = endBal - startBal;
      const diff = impliedNet - netChangeAll;
      const diffAbs = Math.abs(diff);
      if (diffAbs > 0.01) {
        els.balanceHint.textContent += ` • Warning: Balance delta (${money(impliedNet)}) differs from summed tx (${money(netChangeAll)}) by ${money(diff)}. (Usually means missing tx or the balance column is not a true running balance.)`;
      }
    }
  }

  // Table
  els.countPill.textContent = `${monthTx.length} tx`;
  els.tableBody.innerHTML = "";

  monthTx
    .slice()
    .sort((a,b) => a.dateISO < b.dateISO ? 1 : -1)
    .slice(0, 500)
    .forEach(t => {
      const row = document.createElement("tr");
      const amtClass = t.amount >= 0 ? "pos" : "neg";
      row.innerHTML = `
        <td class="mono">${t.dateISO}</td>
        <td>${t.name}</td>
        <td>${t.memo || ""}</td>
        <td class="mono">${t.type || ""}</td>
        <td><span class="pill">${t.category}</span></td>
        <td class="mono ${amtClass}">${money(t.amount)}</td>
        <td class="mono">${(typeof t.balance === "number") ? money(t.balance) : ""}</td>
      `;
      els.tableBody.appendChild(row);
    });
}

/* =========================
   Reset controls
========================= */
function resetThisMonth() {
  const sel = getSelectedMonth();

  // 1) remove marker rows for this month (those you added)
  allTransactions = allTransactions.filter(t => !(t.month === sel && t.category === "Starting Balance"));

  // 2) set an override to ignore Balance column for this month (optional; user requested a way to "reset")
  // If you want it to still use the Balance column after reset, set ignoreBalance=false instead.
  monthOverrides[sel] = { ignoreBalance: false };

  saveAll();
  els.status.textContent = `Reset completed for ${sel}. (Removed marker rows; balance will use Balance column if present.)`;
  updateDashboard();
}

function clearAll() {
  if (!confirm("Start fresh? This deletes ALL imported data and resets everything.")) return;
  allTransactions = [];
  monthOverrides = {};
  localStorage.clear();
  els.status.textContent = "Deleted everything. Start by importing a new CSV.";
  els.debug.textContent = "";
  els.monthSelect.value = yyyymmFromDate(new Date());
  updateDashboard();
}

/* =========================
   Wire UI
========================= */
els.monthSelect.addEventListener("change", updateDashboard);

els.resetMonthBtn.addEventListener("click", () => {
  if (!confirm("Reset THIS month? This removes any marker rows you added for this month. It will keep all other history.")) return;
  resetThisMonth();
});

els.clearBtn.addEventListener("click", clearAll);

els.importBtn.addEventListener("click", async () => {
  const f = els.fileInput.files && els.fileInput.files[0];
  if (!f) { els.status.textContent = "Pick a CSV file first."; return; }

  els.status.textContent = "Importing…";
  els.debug.textContent = "";

  try {
    const res = await importCSVFile(f);
    els.status.textContent = `Imported. Added ${res.added}, skipped ${res.skipped} dupes, failed ${res.failed}. Balance column detected: ${res.hasBalanceColumn ? "Yes" : "No"}.`;

    if (res.debugRows.length) {
      els.debug.textContent =
        "Parsed sample rows:\n" +
        res.debugRows.map(r =>
          `${r.dateISO} | ${r.name} | ${r.memo || ""} | amt=${r.amount} | bal=${(r.balance===null?"":r.balance)} | ${r.category}`
        ).join("\n");
    } else {
      els.debug.textContent = "No rows parsed. If this happens, paste your CSV header row here and I’ll map it.";
    }

    updateDashboard();
  } catch (e) {
    els.status.textContent = `Import failed: ${e.message || e}`;
  } finally {
    els.fileInput.value = "";
  }
});

/* =========================
   Init
========================= */
(function init() {
  els.monthSelect.value = yyyymmFromDate(new Date());
  updateDashboard();
})();
</script>

</body>
</html>
